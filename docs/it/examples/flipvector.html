<!DOCTYPE html>
<html class="writer-html5" lang="it" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FlipVector &mdash; Sistemi Operativi 0 documentazione</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
        <script src="../_static/js/custom.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Indice" href="../genindex.html" />
    <link rel="search" title="Cerca" href="../search.html" />
    <link rel="next" title="CoPy" href="cp.html" />
    <link rel="prev" title="MinShell - le funzioni exec" href="minshell.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="/it/examples/flipvector.html"><img src="/it/_static/it.png"/></a>
            <a href="/en/examples/flipvector.html"><img src="/it/_static/en.png"/></a>
            <a href="../index.html" class="icon icon-home"> Sistemi Operativi
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../linux_install.html">Installare Linux</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../examples.html">Esempi di programmazione</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="few.html">FEW - Fork-Exit-Wait</a></li>
<li class="toctree-l2"><a class="reference internal" href="pfew.html">PFEW - FEW basato su posix threads</a></li>
<li class="toctree-l2"><a class="reference internal" href="pvst.html">PVST - Processi vs Thread</a></li>
<li class="toctree-l2"><a class="reference internal" href="minshell.html">MinShell - le funzioni exec</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">FlipVector</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#le-funzioni-di-acquire-e-release">Le funzioni di acquire e release</a></li>
<li class="toctree-l3"><a class="reference internal" href="#risultati">Risultati</a></li>
<li class="toctree-l3"><a class="reference internal" href="#riferimenti">Riferimenti</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cp.html">CoPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="dup.html">Dup</a></li>
<li class="toctree-l2"><a class="reference internal" href="prodcons.html">ProdCons</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../questions.html">Esercizi di preparazione</a></li>
<li class="toctree-l1"><a class="reference internal" href="../slides.html">Slides</a></li>
<li class="toctree-l1"><a class="reference internal" href="../lectures/index.html">Diario delle lezioni</a></li>
<li class="toctree-l1"><a class="reference internal" href="../news.html">News</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Sistemi Operativi</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../examples.html">Esempi di programmazione</a> &raquo;</li>
      <li>FlipVector</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/examples/flipvector.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="flipvector">
<h1>FlipVector<a class="headerlink" href="#flipvector" title="Link a questa intestazione">¶</a></h1>
<p><span class="raw-html"><a class="external" target="_blank" href="https://github.com/SistemiOperativi/c_examples/blob/main/flip_vector/flip_vector.c">FlipVector</a>
<a class="fa fa-github external" target="_blank" href="https://github.com/SistemiOperativi/c_examples/blob/main/flip_vector/flip_vector.c"></a></span>
è un programma C il cui obiettivo è mostrare diversi aspetti nell’utilizzo e gestione dei thread.</p>
<p>In questo programma vengono creati molteplici thread che manipolano un array condiviso.
Nello specifico, ciascun thread inverte ripetutamente la posizione di ciascuna entry nell’array, la cui dimensione è un numero pari.
A seguire, la funzione <em>stress_test</em> implementa tale operazione:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="nf">stress_test</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">arg</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="kt">long</span><span class="w"> </span><span class="n">my_ops</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">pthread_barrier_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptbarrier</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">stop</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="n">acquire</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">ARRAY_LEN</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="n">shared</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">shared</span><span class="p">[</span><span class="n">ARRAY_LEN</span><span class="mi">-1</span><span class="o">-</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="n">shared</span><span class="p">[</span><span class="n">ARRAY_LEN</span><span class="mi">-1</span><span class="o">-</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">shared</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="n">shared</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">^=</span><span class="w"> </span><span class="n">shared</span><span class="p">[</span><span class="n">ARRAY_LEN</span><span class="mi">-1</span><span class="o">-</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">release</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="n">my_ops</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="n">__sync_fetch_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ops</span><span class="p">,</span><span class="w"> </span><span class="n">my_ops</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition question" id="question-note-0">
<p class="admonition-title">Domanda</p>
<p>Come è possibile modificare il ciclo interno per gestire array di taglia generica?</p>
</div>
<div class="admonition observation" id="observation-note-0">
<p class="admonition-title">Osservazione</p>
<p>L’operatore <code class="code docutils literal notranslate"><span class="pre">^</span></code> implementa la semantica di eXclusive OR (<a class="reference external" href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Bitwise-Logical-Operators">XOR</a>) bit a bit. La relativa tabella di verità è la seguente:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 27%" />
<col style="width: 27%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>X</p></th>
<th class="head"><p>Y</p></th>
<th class="head"><p>X^Y</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>0</p></td>
<td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>1</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
<p>In altre parole se i due bit di input sono uguali l’output è pari a 0. Viceversa se sono diversi l’output è pari ad 1. Di conseguenza,
<code class="code docutils literal notranslate"><span class="pre">x^x=0</span></code>.</p>
<div class="admonition question" id="question-note-1">
<p class="admonition-title">Domanda</p>
<p>Come è stato utilizzato lo XOR per implementare lo scambio del contenuto di due variabili?</p>
</div>
</div>
<p>Essendo l’array condiviso, la sincronizzazione è necessaria al fine di manipolare correttamente l’array.
Le funzioni <code class="code docutils literal notranslate"><span class="pre">acquire</span></code> e <code class="code docutils literal notranslate"><span class="pre">release</span></code> assolvono a questo scopo, utilizzando primitive di lock nella loro implementazione.</p>
<p>Il programma misura le perfomance dell’applicazione in termini di sezioni critiche eseguite.
Per assicurarsi che ciascun thread lavori con la massima concorrenza, questi aspettano che tutti i thread raggiungono la medesima riga di codice,
prima di cominciare a manipolare l’array.
Questo è ottenuto grazie alla primitiva di sincronizzazione <code class="code docutils literal notranslate"><span class="pre">pthread_barrier_wait</span></code>, che blocca un thread fintanto che <em>N</em> thread non invocano la medesima funzione sul medesimo oggetto inizializzato a <em>N</em>.</p>
<div class="admonition observation" id="observation-note-1">
<p class="admonition-title">Osservazione</p>
<p>Una barriera può esser vista come un particolare semaforo che:</p>
<ul class="simple">
<li><p>può assumere valori negativi</p></li>
<li><p>inizializzato a -<em>N</em></p></li>
<li><dl class="simple">
<dt>l’operazione di wait incrementa il contatore di 1 unità</dt><dd><ul>
<li><p>se il semaforo è negativo il thread rimane bloccato in attesa</p></li>
<li><p>se il semaforo assume valore pari a 0, tutti i thread in attesa vengono sbloccati e il valore resettato a -<em>N</em></p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<p>Prima di terminare ciascun thread utilizza una RMW per incrementare un contatore globale <code class="code docutils literal notranslate"><span class="pre">ops</span></code> del numero di operazioni complessivamente eseguite dai thread.
A tal scopo si è utilizzata la funzione <code class="code docutils literal notranslate"><span class="pre">__sync_fetch_and_add</span></code>.</p>
<div class="admonition warning">
<p class="admonition-title">Avvertimento</p>
<p>Le operazioni builtin __sync di gcc sono semplici da utilizzare, ma deprecate.
La versione di riferimento è <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html#g_t_005f_005fatomic-Builtins">__atomic builtin</a>, che tuttavia tengono conto anche del modello di memoria secondo lo
<a class="reference external" href="https://en.cppreference.com/w/cpp/atomic/memory_order">standard C++11</a>.
Per ulteriori dettagli consultare <a class="reference external" href="https://gcc.gnu.org/wiki/Atomic/GCCMM/AtomicSync">AtomicSync</a>.</p>
</div>
<div class="admonition question" id="question-note-2">
<p class="admonition-title">Domanda</p>
<p>Come è possibile implementare l’accumulo del numero di operazioni globalmente eseguite senza utilizzare istruzioni RMW?</p>
</div>
<p>Ciascun thread termina non appena la variabile <code class="code docutils literal notranslate"><span class="pre">stop</span></code> assume valore pari a <code class="code docutils literal notranslate"><span class="pre">true</span></code>.</p>
<p>Il test viene ripetuto con molteplici configurazioni, ossia al variare dei thread <strong>e</strong> del tipo di lock.
Il tutto è coordinato dal main thread secondo lo schema che segue.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">MAX_THREADS</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;&lt;=</span><span class="mi">1</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="p">(</span><span class="n">lock_type</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">lock_type</span><span class="o">&lt;</span><span class="n">num_locks</span><span class="p">;</span><span class="n">lock_type</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">        </span><span class="p">...</span><span class="w"></span>
<span class="w">        </span><span class="n">pthread_barrier_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptbarrier</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w">    </span><span class="n">pthread_create</span><span class="p">(</span><span class="n">ptids</span><span class="w"> </span><span class="o">+</span><span class="n">j</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">,</span><span class="w"> </span><span class="n">stress_test</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">sleep</span><span class="p">(</span><span class="n">SECONDS</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">__sync_bool_compare_and_swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">stop</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">;</span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w">    </span><span class="n">pthread_join</span><span class="p">(</span><span class="n">ptids</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="w">  </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">pthread_barrier_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptbarrier</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition observation" id="observation-note-2">
<p class="admonition-title">Osservazione</p>
<p>L’operatore <code class="code docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> è l’operatore di <a class="reference external" href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Bit-Shifting">shift</a> a sinistra.
Considerando una variabile unsigned <em>x</em> a 8 bit con valore 4 la sua rappresentazione binaria è 0000 0100.
L’istruzione <code class="code docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">1</span></code> indica l’operazione di shift a sinistra di una posizione della variabile <em>x</em>, il cui risultato è pari a
0000 1000, ossia x assume il valore 8.
L’operatore <code class="code docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> è l’operatore di shift a destra.</p>
</div>
<div class="admonition question" id="question-note-3">
<p class="admonition-title">Domanda</p>
<ul class="simple">
<li><p>Quali operazioni matematiche possono essere implementate tramite gli operatori <code class="code docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> e <code class="code docutils literal notranslate"><span class="pre">&gt;&gt;</span></code>?</p></li>
<li><p>Quante iterazioni esegue il seguente ciclo <code class="code docutils literal notranslate"><span class="pre">for(i=1;i&lt;=MAX_THREADS;i&lt;&lt;=1)</span></code>?</p></li>
</ul>
</div>
<p>Per ciascun test, il main thread:</p>
<blockquote>
<div><ul class="simple">
<li><p>inizializza la barriera</p></li>
<li><p>crea i thread</p></li>
<li><p>va in sleep per <code class="code docutils literal notranslate"><span class="pre">SECONDS</span></code> secondi</p></li>
<li><p>setta la variabile <code class="code docutils literal notranslate"><span class="pre">stop</span></code> ad 1 con un’istruzione atomica</p></li>
<li><p>attende la terminazione di ciascun thread</p></li>
<li><p>distrugge la barriera</p></li>
</ul>
</div></blockquote>
<p>La variabile <code class="code docutils literal notranslate"><span class="pre">lock_type</span></code> è una variabile globale utilizzata all’interno di <code class="code docutils literal notranslate"><span class="pre">acquire</span></code> e <code class="code docutils literal notranslate"><span class="pre">release</span></code> per selezionare l’implementazione di lock da utilizzare.</p>
<div class="admonition question" id="question-note-4">
<p class="admonition-title">Domanda</p>
<ul class="simple">
<li><p>Perché la barriera viene distrutta ad ogni fine iterazione e inizializzata ad inizio iterazione?</p></li>
<li><p>Quale altra istruzione RMW poteva essere usata al posto della <em>compare&amp;swap</em>?</p></li>
</ul>
</div>
<p>Il test misura e stampa il numero di operazioni effettuate in concorrenza da tutti i thread in un intervallo di tempo predefinito.
Inoltre, prima di eseguire il suddetto ciclo, il main thread:</p>
<blockquote>
<div><ul>
<li><p>inizializza le primitive di lock della libreria pthread</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">pthread_spin_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptspin</span><span class="p">,</span><span class="w">  </span><span class="n">PTHREAD_PROCESS_PRIVATE</span><span class="p">);</span><span class="w"></span>
<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptmutex</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
<li><p>limita i core su cui i thread possono andare in esecuzione</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">cpu_set_t</span><span class="w"> </span><span class="n">my_set</span><span class="p">;</span><span class="w"></span>
<span class="n">CPU_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_set</span><span class="p">);</span><span class="w"></span>
<span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">CORES</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">    </span><span class="n">CPU_SET</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_set</span><span class="p">);</span><span class="w"></span>
<span class="n">sched_setaffinity</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">cpu_set_t</span><span class="p">),</span><span class="w"> </span><span class="o">&amp;</span><span class="n">my_set</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<div class="admonition warning">
<p class="admonition-title">Avvertimento</p>
<p>sched_affinity è una funzione non POSIX</p>
</div>
<div class="admonition question" id="question-note-5">
<p class="admonition-title">Domanda</p>
<ul class="simple">
<li><p>Perché la set affinity viene utilizzata dal main thread?</p></li>
<li><p>L’uso di set affinity garantisce che ciascun thread andrà in esecuzione sul medesimo core? Se sì, perché? Se no, come è possibile garantirlo?</p></li>
</ul>
</div>
<section id="le-funzioni-di-acquire-e-release">
<h2>Le funzioni di acquire e release<a class="headerlink" href="#le-funzioni-di-acquire-e-release" title="Link a questa intestazione">¶</a></h2>
<p>Le funzioni di acquire e release utilizzano una specifica implementazione di lock in funzione del valore assunto dalla variabile globale <code class="code docutils literal notranslate"><span class="pre">lock_type</span></code>.
Nello specifico supportano 5 implementazioni differenti di lock:</p>
<ol class="arabic simple">
<li><p>pthread spin lock (PT_TAS)</p></li>
<li><p>pthread mutex (PT_MUTEX)</p></li>
<li><p>test-and-set spin lock (TAS)</p></li>
<li><p>test-and-test-and-set spin lock (TTAS)</p></li>
<li><p>ticket spin lock (TICKET)</p></li>
</ol>
<p>Nel caso di lock forniti dalla libreria pthread, acquire e release ridirezionano sulle rispettive funzioni di libreria.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">acquire</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">lock_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PT_TTAS</span><span class="p">)</span><span class="w"> </span><span class="n">pthread_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptspin</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">lock_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PT_MUTEX</span><span class="p">)</span><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptmutex</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">release</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">lock_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PT_TTAS</span><span class="p">)</span><span class="w">                    </span><span class="n">pthread_spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptspin</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">lock_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">PT_MUTEX</span><span class="p">)</span><span class="w">                   </span><span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptmutex</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>Chiaramente, le variabili <em>ptspin</em> e <em>ptmutex</em> sono variabili globali.</p>
<p>Anche i lock TAS e TTAS sono delle variabili globali intere.
Il valore 0 indica che il lock è libero e 1 indica che il lock è stato acquisito da un qualche thread.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">volatile</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">acquire</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">lock_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TAS</span><span class="p">)</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">__sync_lock_test_and_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">lock_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TTAS</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">__sync_lock_test_and_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="w"></span>
<span class="w">            </span><span class="k">while</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">release</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">lock_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TAS</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">lock_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TTAS</span><span class="p">){</span><span class="w">  </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="o">:::</span><span class="s">&quot;memory&quot;</span><span class="p">);</span><span class="w">   </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;}</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition observation" id="observation-note-3">
<p class="admonition-title">Osservazione</p>
<ul class="simple">
<li><p>la variabile <em>lock</em> è dichiarata <strong>volatile</strong>. Questo garantisce che il compilatore non attuerà alcune ottimizzazioni, garantendo che ogni accesso alla variabile <em>lock</em> verrà effettuato sempre in memoria. Ad esempio, il compilatore non potrà usare i registri general purpose come cache per la variabile.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">asm</span> <span class="pre">volatile</span> <span class="pre">(&quot;&quot;:::&quot;memory&quot;);</span></code> costituisce una barriera per il compilatore. Di conseguenza, quest’ultimo non può spostare istruzioni che seguono la barriera prima di quest’ultima e viceversa. <em>asm</em> indica al compilatore che si sta innestando all’interno di codice C del codice assembly.
In questo caso, l’istruzione innestata <code class="code docutils literal notranslate"><span class="pre">&quot;&quot;</span></code> è nulla.
Siccome, il codice innestato è nullo, è necessario indicare al compilatore di non eliminare l’istruzione tramite il token <strong>volatile</strong>.
Infine, l’ultimo parametro <code class="code docutils literal notranslate"><span class="pre">&quot;memory&quot;</span></code> indica al compilatore che l’istruzione accede in modo impredicibile alla memoria, disabilitando ulteriori ottimizzazioni come il riordinamento delle operazioni di scrittura/lettura.
Per approfondimenti sul tema consultare la documentazione di GCC riguardo gli <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Extended-Asm.html">extended-asm</a>.</p></li>
</ul>
</div>
<div class="admonition note">
<p class="admonition-title">Nota</p>
<p>Provare a dichiarare la variabile <em>lock</em> come <strong>int</strong> piuttosto che <strong>volatile int</strong> e vederne gli effetti quando si compila con il massimo livello di ottimizzazione (e.g. <code class="code docutils literal notranslate"><span class="pre">gcc</span> <span class="pre">-O3</span></code>).</p>
</div>
<p>Infine, il ticket lock (TICKET) è implementato come una coppia di variabili globali <em>lock</em> e <em>now</em> di tipo <strong>volatile int</strong>, che indicano rispettivamente l’ultimo ticket servito e il ticket corrente.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">volatile</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">...</span><span class="w"></span>
<span class="k">volatile</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">acquire</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">lock_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TICKET</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">myticket</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__sync_fetch_and_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">now</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">myticket</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">release</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">lock_type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TICKET</span><span class="p">){</span><span class="w">                    </span><span class="k">asm</span><span class="w"> </span><span class="k">volatile</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="o">:::</span><span class="s">&quot;memory&quot;</span><span class="p">);</span><span class="w">   </span><span class="n">now</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">now</span><span class="o">+</span><span class="mi">1</span><span class="p">;}</span><span class="w"></span>
<span class="w">    </span><span class="p">...</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<div class="admonition question" id="question-note-6">
<p class="admonition-title">Domanda</p>
<p>L’algoritmo di ticket lock mostrato è corretto? Se sì, cercare di mostrare perché? Se no, mostrare un caso in cui l’algoritmo non garantisce mutua eclusione o progresso.</p>
</div>
</section>
<section id="risultati">
<h2>Risultati<a class="headerlink" href="#risultati" title="Link a questa intestazione">¶</a></h2>
<p>In questa sezione vengono discussi i risultati ottenuti compilando con:</p>
<ul class="simple">
<li><p>MAX_THREADS = 32</p></li>
<li><p>CORES = 4</p></li>
<li><p>ARRAY_LEN = 256</p></li>
<li><p>SECONDS = 5</p></li>
<li><p>gcc -O3</p></li>
</ul>
<p>Il sistema è equipaggiato con:</p>
<ul class="simple">
<li><p>CPU = Intel(R) Core(TM) i7-7700HQ CPU &#64; 2.80GHz</p></li>
<li><p>CC = gcc 9.3.0</p></li>
<li><p>LIBC = glibc 2.31</p></li>
<li><p>LIBPTHREAD = NPTL 2.31</p></li>
</ul>
<p>A seguire i risultati.</p>
<figure class="align-default">
<img alt="../_images/flipPerf.svg" src="../_images/flipPerf.svg" /></figure>
<p>Le massime performance (numero di sezioni critiche eseguite) sono raggiunte da tutti i lock in assenza di concorrenza.
Quando il numero di thread è maggiore di 1, le performance deteriorano a causa della contesa.
Il degrado aumenta con thread count crescenti per gli spin lock (attesa attiva).
L’uso ridotto di RMW nei TTAS giustifica le differenze con TAS.
Il pthread mutex (PT-MUTEX) mantiene performance quasi inalterate in quanto riduce la contesa sulle risorse hardware (thread in attesa fuori dalla run queue).
Non appena il numero di thread è maggiore del numero di core usabili, il ticket lock (spin+FIFO) ha un drastico crollo delle performance.</p>
<div class="admonition question" id="question-note-7">
<p class="admonition-title">Domanda</p>
<p>Cosa giustifica il comportamento di TICKET?</p>
</div>
</section>
<section id="riferimenti">
<h2>Riferimenti<a class="headerlink" href="#riferimenti" title="Link a questa intestazione">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_barrier_init.html">pthread_barrier_init</a></p></li>
<li><p><a class="reference external" href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_barrier_wait.html">pthread_barrier_wait</a></p></li>
<li><p><a class="reference external" href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Bitwise-Logical-Operators">bitwise XOR</a></p></li>
<li><p><a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/_005f_005fsync-Builtins.html">__sync gcc builtin</a></p></li>
<li><p><a class="reference external" href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_spin_init.html">pthread_spin_init</a></p></li>
<li><p><a class="reference external" href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html">pthread_mutex_init</a></p></li>
<li><p><a class="reference external" href="https://man7.org/linux/man-pages/man2/sched_setaffinity.2.html">sched_setaffinity</a></p></li>
<li><p><a class="reference external" href="https://man7.org/linux/man-pages/man3/CPU_SET.3.html">CPU_SET</a></p></li>
<li><p><a class="reference external" href="https://www.gnu.org/software/gnu-c-manual/gnu-c-manual.html#Bit-Shifting">shift</a></p></li>
<li><p><a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Extended-Asm.html">extended-asm</a></p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="minshell.html" class="btn btn-neutral float-left" title="MinShell - le funzioni exec" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="cp.html" class="btn btn-neutral float-right" title="CoPy" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Romolo Marotta.
      <span class="lastupdated">Ultimo aggiornamento 13 dic 2021.
      </span></p>
  </div>
  <div><p>Flag icons made by <a href="https://www.freepik.com" title="Freepik">Freepik</a> from <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a><p></div>

 

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>