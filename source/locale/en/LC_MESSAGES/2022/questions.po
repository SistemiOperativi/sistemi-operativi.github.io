# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Romolo Marotta
# This file is distributed under the same license as the Sistemi Operativi
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Sistemi Operativi \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-12-20 13:16+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../source/2022/questions.rst:2
msgid "Esercizi di preparazione"
msgstr ""

#: ../source/2022/questions.rst:4
msgid ""
"In questa sezione vengono riportate alcuni esercizi/domande che possono "
"essere utilizzate come preparazione all'esame."
msgstr ""

#: ../source/2022/questions.rst:8
msgid "Domande"
msgstr ""

#: ../source/2022/q_exercises/intro.rst:2 ../source/2022/questions/intro.rst:2
msgid "1 - Introduzione"
msgstr ""

#: ../source/2022/questions/intro.rst:4
msgid ""
"Descrivere il concetto di interrupt e mostrare il suo utilizzo nei "
"sistemi operativi."
msgstr ""

#: ../source/2022/questions/intro.rst:5
msgid "Descrivere le principali strutture dati di un sistema operativo."
msgstr ""

#: ../source/2022/questions/intro.rst:6
msgid ""
"Descrivere i principali benefici e le criticità introdotte della "
"multiprogrammazione."
msgstr ""

#: ../source/2022/questions/intro.rst:7
msgid ""
"Cosa sono le system call e quali relazioni hanno con le librerie di "
"sistema?"
msgstr ""

#: ../source/2022/questions/intro.rst:8
msgid ""
"Riportare esempi di supporti hardware necessari al sistema operativo per "
"garantire la protezione delle risorse."
msgstr ""

#: ../source/2022/questions/intro.rst:9
msgid "Quali sono gli obiettivi principali di un sistema operativo?"
msgstr ""

#: ../source/2022/questions/intro.rst:10
msgid ""
"Perché la distinzione tra modo kernel e modo user è una forma di "
"protezione?"
msgstr ""

#: ../source/2022/questions/intro.rst:11
msgid ""
"Descrivere 3 servizi di sistema operativo e spiegare perché sono "
"convenienti per gli utenti. Inoltre, perché è sconveniente che siano "
"forniti da programmi user?"
msgstr ""

#: ../source/2022/questions/intro.rst:12
msgid ""
"Descrivere le principali caratteristiche di un sistema batch e di un "
"sistema batch multiprogrammato, discutendo anche in modo comparativo i "
"vantaggi o svantaggi dell'uno verso l'altro."
msgstr ""

#: ../source/2022/questions/processes.rst:2
msgid "2- Processi e thread"
msgstr ""

#: ../source/2022/questions/processes.rst:4
msgid "Descrivi il concetto di mode switch e di process switch."
msgstr ""

#: ../source/2022/questions/processes.rst:5
msgid ""
"Descrivi il concetto di processo. Quali sono i possibili stati di un "
"processo?"
msgstr ""

#: ../source/2022/questions/processes.rst:6
msgid ""
"Quando un processo viene creato tramite *fork*, cosa è condiviso tra "
"processo parent e child?"
msgstr ""

#: ../source/2022/questions/processes.rst:7
msgid "Spiegare la differenza tra il processo e thread."
msgstr ""

#: ../source/2022/questions/processes.rst:8
msgid "Quale è la differenza tra User-Level Thread e Kernel-Level Thread?"
msgstr ""

#: ../source/2022/questions/processes.rst:9
msgid ""
"Quando un thread viene creato tramite *pthread_create*, cosa è condiviso "
"tra thread parent e child?"
msgstr ""

#: ../source/2022/questions/sync.rst:2
msgid "3 - Sincronizzazione"
msgstr ""

#: ../source/2022/questions/sync.rst:4
msgid "Cos'è un'istruzione Read-Modify-Write?"
msgstr ""

#: ../source/2022/questions/sync.rst:5
msgid "Descrivere cosa è un lock e relative proprietà di correttezza e progresso."
msgstr ""

#: ../source/2022/questions/sync.rst:6
msgid "Descrivere il Bakery algorithm."
msgstr ""

#: ../source/2022/questions/sync.rst:7
msgid ""
"Gli spinlock sono appropriati in un sistema single-core? Motiva la tua "
"risposta."
msgstr ""

#: ../source/2022/q_exercises/sched.rst:2 ../source/2022/questions/sched.rst:2
msgid "4 - Scheduling"
msgstr ""

#: ../source/2022/questions/sched.rst:4
msgid "Cpu-scheduler: quali sono i criteri di valutazione di un CPU scheduler?"
msgstr ""

#: ../source/2022/questions/sched.rst:5
msgid ""
"Quali sfide introducono le architetture multicore nell'ambito del CPU "
"scheduling?"
msgstr ""

#: ../source/2022/questions/sched.rst:6
msgid "Quale è la differenza tra uno scheduler preemtive e uno non-preemptive?"
msgstr ""

#: ../source/2022/questions/sched.rst:7
msgid ""
"Descrivere la politica Shortest Job First e discuterne vantaggi e "
"svantaggi."
msgstr ""

#: ../source/2022/questions/sched.rst:8
msgid "Descrivere la politica Round Robin e discuterne vantaggi e svantaggi."
msgstr ""

#: ../source/2022/questions/sched.rst:9
msgid ""
"Descrivere la politica di Fair-Share scheduling e quali problematiche "
"risolve."
msgstr ""

#: ../source/2022/questions/sched.rst:10
msgid "Descrivere lo scheduler Complete Fair Share in Linux."
msgstr ""

#: ../source/2022/questions/sched.rst:11
msgid "Descrivere lo scheduler Multilevel Feedback Queue."
msgstr ""

#: ../source/2022/questions/sched.rst:12
msgid ""
"Quale è il vantaggio di avere time-slice differenti in uno scheduler "
"basato su code multilivello con feedback?"
msgstr ""

#: ../source/2022/questions/sched.rst:13
msgid ""
"Come è possibile parametrizzare uno scheduler basato su priorità per "
"emulare gli scheduler Shortest Job First, First Come First Serve?"
msgstr ""

#: ../source/2022/questions/sched.rst:14
msgid ""
"Descrivere lo scheduler di CPU round-robin virtuale, discutendone "
"vantaggi e svantaggi rispetto allo scheduler round-robin."
msgstr ""

#: ../source/2022/questions/sched.rst:15
msgid ""
"Si descrivano gli scheduler di CPU Shortest-Process-Next (SPN) e la sua "
"variante Shortest–Remaining-Time-Next (SRTN), evidenziandone i vantaggi e"
" gli svantaggi."
msgstr ""

#: ../source/2022/q_exercises/IO.rst:2 ../source/2022/questions/IO.rst:2
msgid "5 - I/O Management"
msgstr ""

#: ../source/2022/questions/IO.rst:4
msgid ""
"Quali sono le difficoltà che introduce il Direct Memory Access rispetto "
"alla gestione dei processi?"
msgstr ""

#: ../source/2022/questions/IO.rst:5
msgid "Descrivere la tecnica di I/O buffering e la sua utilità."
msgstr ""

#: ../source/2022/questions/IO.rst:6
msgid "Spiegare le criticità nel progettare politiche di I/O scheduling."
msgstr ""

#: ../source/2022/questions/IO.rst:7
msgid ""
"Descrivere le politiche First-Come-First-Served e Shortest-Seek-Time-"
"First per disk scheduling e illustrarne vantaggi e svantaggi."
msgstr ""

#: ../source/2022/questions/IO.rst:8
msgid ""
"Descrivere la politica SCAN per disk scheduling e spiegarne vantaggi e "
"limiti. Per le limitazioni descritte, riportare possibili soluzioni."
msgstr ""

#: ../source/2022/q_exercises/file.rst:2 ../source/2022/questions/file.rst:2
msgid "6 - File management"
msgstr ""

#: ../source/2022/questions/file.rst:4
msgid "Cosa è un file e quali sono i suoi principali attributi?"
msgstr ""

#: ../source/2022/questions/file.rst:5
msgid "Cosa è un file system e quali sono i suoi compiti principali?"
msgstr ""

#: ../source/2022/questions/file.rst:6
msgid "Descrivere i metodi di accesso a file sequenziale, diretto ed indicizzato."
msgstr ""

#: ../source/2022/questions/file.rst:7
msgid "Descrivere le caratteristiche salienti del file system UNIX."
msgstr ""

#: ../source/2022/questions/file.rst:8
msgid "Cosa è un in-memory file system e riportarne alcuni esempi."
msgstr ""

#: ../source/2022/questions/file.rst:9
msgid ""
"Descrivere i classici metodi di allocazione dei file sui dispositivi, "
"discutendone vantaggi e svantaggi in modo comparato."
msgstr ""

#: ../source/2022/questions/file.rst:10
msgid ""
"Descrivere cosa sono gli \"hard link\" ed i \"soft link\" in un file-"
"system."
msgstr ""

#: ../source/2022/questions/file.rst:11
msgid "Si descriva il metodo di allocazione dei file a catena."
msgstr ""

#: ../source/2022/q_exercises/memory.rst:2
#: ../source/2022/questions/memory.rst:2
msgid "7 - Gestione della memoria"
msgstr ""

#: ../source/2022/questions/memory.rst:4
msgid ""
"Descrivi la paginazione e la segmentazione mostrando vantaggi e svantaggi"
" di ciascuna."
msgstr ""

#: ../source/2022/questions/memory.rst:5
msgid ""
"Mostra lo schema di paginazione a due livelli e il processo di traduzione"
" di un indirizzo virtuale in fisico. Quali sono i vantaggi e gli "
"svantaggi nell'uso di tale schema?"
msgstr ""

#: ../source/2022/questions/memory.rst:6
msgid "Cosa è e a cosa serve il translation lookside buffer?"
msgstr ""

#: ../source/2022/questions/memory.rst:7
msgid ""
"Mostrare uno schema di segmentazione paginata con TLB e descriverne il "
"funzionamento per la traduzione da indirizzo logico a fisico."
msgstr ""

#: ../source/2022/questions/memory.rst:8
msgid "Che cosa è un buddy system?"
msgstr ""

#: ../source/2022/questions/memory.rst:9
msgid "Descrivi l'anomalia di Belady."
msgstr ""

#: ../source/2022/questions/memory.rst:10
msgid ""
"Descrivere l'algoritmo dell'orologio nell'ambito delle politiche di "
"replacement delle pagine."
msgstr ""

#: ../source/2022/questions/memory.rst:11
msgid "Descrivere gli aspetti principali di gestione della memoria virtuale."
msgstr ""

#: ../source/2022/questions/memory.rst:12
msgid ""
"Descrizione la gestione di un page fault nel caso di memoria virtuale "
"basata su paginazione."
msgstr ""

#: ../source/2022/questions/memory.rst:13
msgid ""
"Descrivere le caratteristiche delle politiche di gestione del resident "
"set di processo."
msgstr ""

#: ../source/2022/questions/memory.rst:14
msgid "Descrivere il fenomeno del thrashing nel contesto della memoria virtuale."
msgstr ""

#: ../source/2022/questions/memory.rst:15
msgid ""
"Descrivere la tecnica di gestione delle memoria basata su partizioni "
"dinamiche, indicando anche di quali supporti per il binding degli "
"indirizzi questa necessita."
msgstr ""

#: ../source/2022/questions/memory.rst:16
msgid ""
"Descrivere l'algoritmo di selezione Least-Recently-Used (LRU) per sistemi"
" di memoria virtuale basati su paginazione."
msgstr ""

#: ../source/2022/questions/memory.rst:17
msgid ""
"Si descriva la tecnica della paginazione, indicando quali siano le "
"strutture dati fondamentali che un sistema operativo deve gestire per "
"metterla in atto."
msgstr ""

#: ../source/2022/questions/memory.rst:18
msgid ""
"Descrivere l'algoritmo ottimo per la sostituzione delle pagine in "
"ambiente di memoria virtuale. Si indichi infine se tale algoritmo soffra "
"o meno dell'anomalia di Belady, motivando la risposta."
msgstr ""

#: ../source/2022/questions/memory.rst:19
msgid ""
"Descrivere la struttura e l'utilizzo della tabella delle pagine e la "
"relazione tra questa ed i componenti hardware presenti su una "
"architettura di processore convenzionale."
msgstr ""

#: ../source/2022/questions.rst:20
msgid "Esercizi di teoria"
msgstr ""

#: ../source/2022/questions.rst:25
msgid ""
"Alcuni esercizi possono deliberatamente ammettere più di una soluzione in"
" funzione delle assunzioni fatte durante lo svolgimento. Di conseguenza, "
"le soluzioni proposte potrebbe non essere le uniche ammissibili."
msgstr ""

#: ../source/2022/q_exercises/intro.rst:5
msgid "Si consideri un programma di cui:"
msgstr ""

#: ../source/2022/q_exercises/intro.rst:7
#, python-format
msgid "il 60% del tempo di esecuzione è parallelizzabile;"
msgstr ""

#: ../source/2022/q_exercises/intro.rst:8
#, python-format
msgid ""
"l'80% del tempo non parallelizzabile può essere ottimizzato tramite "
"l'adozione di un algoritmo 16 volte più veloce."
msgstr ""

#: ../source/2022/q_exercises/intro.rst:10
msgid "Calcolare lo speedup ottenibile tramite:"
msgstr ""

#: ../source/2022/q_exercises/intro.rst:12
msgid "la sola ottimizzazione a) con 2 e 4 core;"
msgstr ""

#: ../source/2022/q_exercises/intro.rst:13
msgid "tramite la sola ottimizzazione b);"
msgstr ""

#: ../source/2022/q_exercises/intro.rst:14
msgid "l'applicazione congiunta di a) e b) con 2 e 4 core."
msgstr ""

#: ../source/2022/q_exercises/intro.rst:16
msgid ""
"Infine, riportare lo speedup massimo raggiungibile tramite ottimizzazione"
" a) e b)."
msgstr ""

#: ../source/2022/q_exercises/sched.rst:5
msgid ""
"Si consideri uno scenario con 4 processi {P1,..., P4} CPU-bound e "
"generati in sequenza a partire da P1 a P4 con ritardi trascurabili."
msgstr ""

#: ../source/2022/q_exercises/sched.rst:6
msgid ""
"Il processo Pi richiede 1/i secondi di CPU per completare la propria "
"esecuzione. Considerando che il ritardo di context-switch sia "
"trascurabile e che RR abbia una time slice pari a 125ms, si calcoli per "
"gli algoritmi FCFS, SPN e RR il tempo di primo accesso alla CPU e il "
"tempo di completamento per ciascun processo."
msgstr ""

#: ../source/2022/q_exercises/file.rst:20
#: ../source/2022/q_exercises/memory.rst:21
#: ../source/2022/q_exercises/memory.rst:90
#: ../source/2022/q_exercises/sched.rst:13
msgid "**Mostra/Nascondi Soluzione**"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:17
msgid "*FCFS*:"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:20
#: ../source/2022/q_exercises/sched.rst:44
#: ../source/2022/q_exercises/sched.rst:67
#: ../source/2022/q_exercises/sched.rst:89
msgid "process"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:20
#: ../source/2022/q_exercises/sched.rst:30
#: ../source/2022/q_exercises/sched.rst:44
#: ../source/2022/q_exercises/sched.rst:54
#: ../source/2022/q_exercises/sched.rst:67
#: ../source/2022/q_exercises/sched.rst:77
#: ../source/2022/q_exercises/sched.rst:89
#: ../source/2022/q_exercises/sched.rst:101
msgid "P1"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:20
#: ../source/2022/q_exercises/sched.rst:32
#: ../source/2022/q_exercises/sched.rst:44
#: ../source/2022/q_exercises/sched.rst:56
#: ../source/2022/q_exercises/sched.rst:67
#: ../source/2022/q_exercises/sched.rst:79
#: ../source/2022/q_exercises/sched.rst:89
#: ../source/2022/q_exercises/sched.rst:103
msgid "P2"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:20
#: ../source/2022/q_exercises/sched.rst:34
#: ../source/2022/q_exercises/sched.rst:44
#: ../source/2022/q_exercises/sched.rst:58
#: ../source/2022/q_exercises/sched.rst:67
#: ../source/2022/q_exercises/sched.rst:81
#: ../source/2022/q_exercises/sched.rst:89
#: ../source/2022/q_exercises/sched.rst:105
msgid "P3"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:20
#: ../source/2022/q_exercises/sched.rst:36
#: ../source/2022/q_exercises/sched.rst:44
#: ../source/2022/q_exercises/sched.rst:60
#: ../source/2022/q_exercises/sched.rst:67
#: ../source/2022/q_exercises/sched.rst:83
#: ../source/2022/q_exercises/sched.rst:89
#: ../source/2022/q_exercises/sched.rst:107
msgid "P4"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:22
#: ../source/2022/q_exercises/sched.rst:46
#: ../source/2022/q_exercises/sched.rst:69
#: ../source/2022/q_exercises/sched.rst:91
msgid "CPU Release Time"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:23
#: ../source/2022/q_exercises/sched.rst:70
#: ../source/2022/q_exercises/sched.rst:107
msgid "1.00"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:23
#: ../source/2022/q_exercises/sched.rst:32
#: ../source/2022/q_exercises/sched.rst:34
msgid "1.5"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:23
#: ../source/2022/q_exercises/sched.rst:34
#: ../source/2022/q_exercises/sched.rst:36
msgid "1.83"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:23
#: ../source/2022/q_exercises/sched.rst:36
#: ../source/2022/q_exercises/sched.rst:47
#: ../source/2022/q_exercises/sched.rst:54
#: ../source/2022/q_exercises/sched.rst:70
#: ../source/2022/q_exercises/sched.rst:79
#: ../source/2022/q_exercises/sched.rst:101
msgid "2.08"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:28
#: ../source/2022/q_exercises/sched.rst:52
#: ../source/2022/q_exercises/sched.rst:75
#: ../source/2022/q_exercises/sched.rst:99
msgid "Processo"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:28
#: ../source/2022/q_exercises/sched.rst:52
#: ../source/2022/q_exercises/sched.rst:75
#: ../source/2022/q_exercises/sched.rst:99
msgid "Primo Accesso"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:28
#: ../source/2022/q_exercises/sched.rst:52
#: ../source/2022/q_exercises/sched.rst:75
#: ../source/2022/q_exercises/sched.rst:99
msgid "Completamento"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:28
#: ../source/2022/q_exercises/memory.rst:31
#: ../source/2022/q_exercises/memory.rst:33
#: ../source/2022/q_exercises/memory.rst:35
#: ../source/2022/q_exercises/memory.rst:37
#: ../source/2022/q_exercises/memory.rst:43
#: ../source/2022/q_exercises/memory.rst:46
#: ../source/2022/q_exercises/memory.rst:48
#: ../source/2022/q_exercises/memory.rst:50
#: ../source/2022/q_exercises/memory.rst:52
#: ../source/2022/q_exercises/memory.rst:59
#: ../source/2022/q_exercises/memory.rst:62
#: ../source/2022/q_exercises/memory.rst:64
#: ../source/2022/q_exercises/memory.rst:66
#: ../source/2022/q_exercises/sched.rst:30
#: ../source/2022/q_exercises/sched.rst:60
#: ../source/2022/q_exercises/sched.rst:77
msgid "0"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:108
#: ../source/2022/q_exercises/sched.rst:30
#: ../source/2022/q_exercises/sched.rst:32
#: ../source/2022/q_exercises/sched.rst:77
#: ../source/2022/q_exercises/sched.rst:83
msgid "1"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:39
msgid "*SPN*:"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:41
msgid ""
"Assunzione 1: Lo scheduler viene attivato dopo l'arrivo di tutti i "
"processi"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:47
#: ../source/2022/q_exercises/sched.rst:58
#: ../source/2022/q_exercises/sched.rst:60
msgid "0.25"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:47
#: ../source/2022/q_exercises/sched.rst:56
#: ../source/2022/q_exercises/sched.rst:58
msgid "0.58"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:47
#: ../source/2022/q_exercises/sched.rst:54
#: ../source/2022/q_exercises/sched.rst:56
msgid "1.08"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:64
msgid "Assunzione 2: Lo scheduler è attivato all'arrivo del primo processo"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:70
#: ../source/2022/q_exercises/sched.rst:81
#: ../source/2022/q_exercises/sched.rst:83
msgid "1.25"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:70
#: ../source/2022/q_exercises/sched.rst:79
#: ../source/2022/q_exercises/sched.rst:81
#: ../source/2022/q_exercises/sched.rst:103
msgid "1.58"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:86
msgid "*RR*:"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
#: ../source/2022/q_exercises/sched.rst:103
msgid "0.125"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
#: ../source/2022/q_exercises/sched.rst:105
msgid "0.250"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
#: ../source/2022/q_exercises/sched.rst:107
msgid "0.375"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "0.500"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "0.625"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "0.750"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "0.875"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "1.000"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "1.125"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "1.250"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "1.333"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "1.458"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "1.583"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "2.083"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:101
msgid "0.000"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:105
msgid "1.33"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:114
msgid ""
"Si consideri uno scenario in cui uno scheduler Multilevel-feedback queue "
"abbia 4 livelli di priorità, ed in cui il quanto di tempo assegnato ai "
"processi al livello i sia di 1/2^i millisecondi. Si supponga che "
"all'istante T0 nascano 2 processi A e B, entrambi CPU-bound. Il processo "
"B richiede 10 millisecondi di tempo di CPU per completare la sua "
"esecuzione. Si identifichi la durata massima (in termini di tempo di CPU)"
" del processo A affinché il processo B possa completare la sua esecuzione"
" entro il tempo T0+17 nei due casi in cui il primo processo ad essere "
"schedulato in CPU sia A oppure B. Si supponga che il tempo di CPU per i "
"context switch e per l'esecuzione dello scheduler sia nullo."
msgstr ""

#: ../source/2022/q_exercises/sched.rst:115
msgid ""
"Si consideri uno scenario in cui al tempo T0 nasca un processo P0 "
"puramente CPU-bound di durata (tempo di CPU) pari a 10 secondi ed al "
"tempo T0 + 3 secondi P0 origini un altro processo P1 puramente CPU-bound "
"di durata (tempo di CPU) pari a 6 secondi. Supponendo che le durate dei "
"processi siano note al tempo della loro generazione, e che il tempo di "
"CPU per eseguire uno scheduler sia trascurabile. si calcoli il tempo "
"massimo di completamento del processo P1 nel caso in cui il sistema abbia"
" come scheduler Shortest Process Next oppure Shortest-Remaining-Time "
"Next."
msgstr ""

#: ../source/2022/q_exercises/IO.rst:4
msgid ""
"Si consideri inoltre uno scenario in cui arrivino al sistema operativo "
"richieste per accedere alle seguenti tracce di un disco: 33 – 46 – 98 – "
"12 – 43 – 56 – 78 - 77 – 25. Si determini la sequenza effettiva di "
"schedulazione delle operazioni verso il disco considerando che:"
msgstr ""

#: ../source/2022/q_exercises/IO.rst:6
msgid ""
"al più 4 richieste per volta possono essere immagazzinate nella coda di "
"scheduling;"
msgstr ""

#: ../source/2022/q_exercises/IO.rst:7
msgid "la testina sia inizialmente posta sulla traccia 100 del disco;"
msgstr ""

#: ../source/2022/q_exercises/IO.rst:8
msgid "l'algoritmo utilizzato è SCAN."
msgstr ""

#: ../source/2022/q_exercises/file.rst:5
msgid ""
"Si consideri un file system con allocazione a catena ed accesso "
"indicizzato. Dato un file:"
msgstr ""

#: ../source/2022/q_exercises/file.rst:7
msgid "contente 1M record;"
msgstr ""

#: ../source/2022/q_exercises/file.rst:8
msgid ""
"il relativo indice ha taglia pari a 512 record e contiene 128 chiavi "
"uniformemente distribuite nel file;"
msgstr ""

#: ../source/2022/q_exercises/file.rst:9
msgid ""
"memorizzato su un dispositivo di massa, la cui taglia di un blocco è pari"
" a 4096 record."
msgstr ""

#: ../source/2022/q_exercises/file.rst:11
msgid "Calcolare la latenza massima e minima considerando che:"
msgstr ""

#: ../source/2022/q_exercises/file.rst:13
msgid "il tempo medio di accesso ad un blocco è 10ms;"
msgstr ""

#: ../source/2022/q_exercises/file.rst:14
msgid "l'accesso ad una chiave dell'indice in ram è pari a 1ms."
msgstr ""

#: ../source/2022/q_exercises/file.rst:24
msgid "Assunzioni:"
msgstr ""

#: ../source/2022/q_exercises/file.rst:26
msgid "L'indice è memorizzato su disco"
msgstr ""

#: ../source/2022/q_exercises/file.rst:27
msgid "L'indice deve essere prima caricato in ram per poter essere utilizzato"
msgstr ""

#: ../source/2022/q_exercises/file.rst:28
msgid "RecordID e RiferimentoBlocco hanno pari taglia"
msgstr ""

#: ../source/2022/q_exercises/file.rst:30
msgid "Svolgimento:"
msgstr ""

#: ../source/2022/q_exercises/file.rst:32
msgid ""
"Taglia di una chiave nell'indice = TagliaIndice/NumeroChiavi = 512R/128 ="
" 4R"
msgstr ""

#: ../source/2022/q_exercises/file.rst:33
msgid "Taglia di un riferimento = 2R"
msgstr ""

#: ../source/2022/q_exercises/file.rst:34
msgid ""
"Record utilizzabili all'interno di un blocco per memorizzare dati di file"
" = Taglia di un blocco - Taglia di un riferimento = 4096-2 = 4094"
msgstr ""

#: ../source/2022/q_exercises/file.rst:35
msgid ""
"Numero di blocchi per memorizzare il file = Numero di record nel file / "
"record utilizzabili = ceil(10^6/4094) = 245"
msgstr ""

#: ../source/2022/q_exercises/file.rst:36
msgid ""
"Distanza media tra due blocchi indicizzati = ceil(Numero di blocchi / "
"numero di chiavi) = 2"
msgstr ""

#: ../source/2022/q_exercises/file.rst:37
msgid ""
"Latenza minima: accesso ad un blocco indicizzato, indice già presente in "
"RAM."
msgstr ""

#: ../source/2022/q_exercises/file.rst:39
msgid ""
"Risultato = Tempo di accesso a indice + Accesso al blocco indicizzato = "
"1ms +10ms = 11ms"
msgstr ""

#: ../source/2022/q_exercises/file.rst:41
msgid ""
"Latenza massima: accesso al blocco più lontano da quello indicizzato, "
"indice NON presente in RAM."
msgstr ""

#: ../source/2022/q_exercises/file.rst:43
msgid ""
"Risultato = Tempo di caricamento indice +  Tempo di accesso a indice + "
"(Numero di blocchi per indice)*(Tempo di accesso al blocco indicizzato) ="
" +10ms + 1ms +2*10ms = 31ms"
msgstr ""

#: ../source/2022/q_exercises/file.rst:55
msgid ""
"Si consideri un file system con allocazione indicizzata ospitato su un "
"dispositivo i cui blocchi hanno taglia pari a 1024 record e un "
"riferimento a blocco occupa 8 record. Il record di sistema ha:"
msgstr ""

#: ../source/2022/q_exercises/file.rst:57
msgid "128 entry per accesso diretto;"
msgstr ""

#: ../source/2022/q_exercises/file.rst:58
msgid "4 entry per accesso indiretto;"
msgstr ""

#: ../source/2022/q_exercises/file.rst:59
msgid "4 entry per accesso doppiamente indiretto."
msgstr ""

#: ../source/2022/q_exercises/file.rst:61
msgid "Qual è la taglia massima di un file in record?"
msgstr ""

#: ../source/2022/q_exercises/file.rst:63
msgid ""
"Si consideri inoltre senario dove un processo P apra un file F "
"(attualmente non in uso da parte di alcun processo) e poi esegua 2 "
"fork(). Indicare il numero delle sessioni di I/O verso  il file F a valle"
" dell'esecuzione delle 2 fork() da parte di P."
msgstr ""

#: ../source/2022/q_exercises/file.rst:64
msgid ""
"Si consideri un dispositivo di memoria di massa con blocchi di taglia "
"pari a 4 KB, indici di blocchi di taglia pari a 4 byte, ed un record di "
"sistema contenente in totale 12 indici di cui N diretti ed M indiretti. "
"Si determini il valore di N ed M, qualora esista, che possa permettere di"
" allocare file di taglia almeno pari a 4 GB."
msgstr ""

#: ../source/2022/q_exercises/file.rst:65
msgid ""
"Si supponga di avere un file system che supporta il metodo di allocazione"
" a catena. Si supponga inoltre che il dispositivo di memoria di massa ove"
" il file system è ospitato abbia blocchi di taglia pari a 4 K record, e "
"che un indice (puntatore) di blocco di dispositivo sia espresso con 16 "
"record. Si supponga inoltre di avere un file F di taglia pari a 16 M "
"record. Si calcoli il numero di blocchi necessari ad allocare il file sul"
" dispositivo di memoria di massa secondo lo schema a catena."
msgstr ""

#: ../source/2022/q_exercises/memory.rst:4
msgid ""
"Si consideri il caso di memoria virtuale basata su paginazione a più "
"livelli, indirizzi logici e fisici a N bit, pagine di 4MB e tabelle pari "
"alla dimensione di una pagina. Rispondere alle seguenti domande "
"considerando N pari a 40 bit e 48 bit."
msgstr ""

#: ../source/2022/q_exercises/memory.rst:7
msgid "Quanti bit servono per spiazzarsi all'interno di una pagina?"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:8
msgid ""
"Quanti bit servono per identificare una pagina nel caso di N uguale a 40 "
"bit e 48 bit?"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:9
msgid ""
"Supponendo di utilizzare un numero di bit per entry in una tabella pari "
"alla minima potenza di 2 necessaria a memorizzare un frame number, quante"
" entry possono essere memorizzate in una tabella?"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:10
msgid "Quanti livelli sono necessari?"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:11
msgid ""
"Qual è la struttura dell'indirizzo e l'utilizzo dei bit nel suddetto "
"schema di paginazione?"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:12
msgid ""
"Qual è il numero massimo di frame di memoria impegnati da un processo nel"
" caso in cui il numero delle tabelle a qualsiasi livello correntemente "
"usate per quel processo in suddetto schema di paginazione sia pari a 10?"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:15
msgid ""
"Data una memoria principale di 4 frame, si determini quanti e quali page "
"fault vengono generati dagli algoritmi FIFO, LRU e Ottimo per la "
"sostituzione delle pagine in sistemi con memoria virtuale data la "
"seguente traccia: 0 9 0 3 5 7 9 0 9 6 7 8 9 7 6 4"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:25
msgid "*FIFO*: #PageFault = 11"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:28
#: ../source/2022/q_exercises/memory.rst:43
#: ../source/2022/q_exercises/memory.rst:59
msgid "**0**"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:28
#: ../source/2022/q_exercises/memory.rst:43
#: ../source/2022/q_exercises/memory.rst:59
msgid "**9**"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:28
#: ../source/2022/q_exercises/memory.rst:43
#: ../source/2022/q_exercises/memory.rst:59
msgid "**3**"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:28
#: ../source/2022/q_exercises/memory.rst:43
#: ../source/2022/q_exercises/memory.rst:59
msgid "**5**"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:28
#: ../source/2022/q_exercises/memory.rst:43
#: ../source/2022/q_exercises/memory.rst:59
msgid "**7**"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:28
#: ../source/2022/q_exercises/memory.rst:31
#: ../source/2022/q_exercises/memory.rst:33
#: ../source/2022/q_exercises/memory.rst:35
#: ../source/2022/q_exercises/memory.rst:37
#: ../source/2022/q_exercises/memory.rst:43
#: ../source/2022/q_exercises/memory.rst:46
#: ../source/2022/q_exercises/memory.rst:48
#: ../source/2022/q_exercises/memory.rst:50
#: ../source/2022/q_exercises/memory.rst:52
#: ../source/2022/q_exercises/memory.rst:59
#: ../source/2022/q_exercises/memory.rst:62
#: ../source/2022/q_exercises/memory.rst:64
#: ../source/2022/q_exercises/memory.rst:66
msgid "9"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:28
#: ../source/2022/q_exercises/memory.rst:43
#: ../source/2022/q_exercises/memory.rst:59
msgid "**6**"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:28
#: ../source/2022/q_exercises/memory.rst:31
#: ../source/2022/q_exercises/memory.rst:33
#: ../source/2022/q_exercises/memory.rst:35
#: ../source/2022/q_exercises/memory.rst:37
#: ../source/2022/q_exercises/memory.rst:43
#: ../source/2022/q_exercises/memory.rst:46
#: ../source/2022/q_exercises/memory.rst:48
#: ../source/2022/q_exercises/memory.rst:50
#: ../source/2022/q_exercises/memory.rst:52
#: ../source/2022/q_exercises/memory.rst:59
#: ../source/2022/q_exercises/memory.rst:62
#: ../source/2022/q_exercises/memory.rst:64
#: ../source/2022/q_exercises/memory.rst:66
#: ../source/2022/q_exercises/memory.rst:96
msgid "7"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:28
#: ../source/2022/q_exercises/memory.rst:43
#: ../source/2022/q_exercises/memory.rst:59
msgid "**8**"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:28
#: ../source/2022/q_exercises/memory.rst:31
#: ../source/2022/q_exercises/memory.rst:33
#: ../source/2022/q_exercises/memory.rst:35
#: ../source/2022/q_exercises/memory.rst:37
#: ../source/2022/q_exercises/memory.rst:43
#: ../source/2022/q_exercises/memory.rst:46
#: ../source/2022/q_exercises/memory.rst:48
#: ../source/2022/q_exercises/memory.rst:50
#: ../source/2022/q_exercises/memory.rst:52
#: ../source/2022/q_exercises/memory.rst:59
#: ../source/2022/q_exercises/memory.rst:62
#: ../source/2022/q_exercises/memory.rst:64
#: ../source/2022/q_exercises/memory.rst:66
#: ../source/2022/q_exercises/memory.rst:98
msgid "6"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:28
#: ../source/2022/q_exercises/memory.rst:43
#: ../source/2022/q_exercises/memory.rst:59
msgid "**4**"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:31
#: ../source/2022/q_exercises/memory.rst:33
#: ../source/2022/q_exercises/memory.rst:35
#: ../source/2022/q_exercises/memory.rst:37
#: ../source/2022/q_exercises/memory.rst:46
#: ../source/2022/q_exercises/memory.rst:48
#: ../source/2022/q_exercises/memory.rst:50
#: ../source/2022/q_exercises/memory.rst:52
#: ../source/2022/q_exercises/memory.rst:66
#: ../source/2022/q_exercises/memory.rst:68
#: ../source/2022/q_exercises/memory.rst:104
msgid "3"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:31
#: ../source/2022/q_exercises/memory.rst:33
#: ../source/2022/q_exercises/memory.rst:35
#: ../source/2022/q_exercises/memory.rst:37
#: ../source/2022/q_exercises/memory.rst:46
#: ../source/2022/q_exercises/memory.rst:48
#: ../source/2022/q_exercises/memory.rst:50
#: ../source/2022/q_exercises/memory.rst:52
#: ../source/2022/q_exercises/memory.rst:68
#: ../source/2022/q_exercises/memory.rst:100
msgid "5"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:31
#: ../source/2022/q_exercises/memory.rst:33
#: ../source/2022/q_exercises/memory.rst:35
#: ../source/2022/q_exercises/memory.rst:46
#: ../source/2022/q_exercises/memory.rst:48
#: ../source/2022/q_exercises/memory.rst:50
#: ../source/2022/q_exercises/memory.rst:52
#: ../source/2022/q_exercises/memory.rst:68
msgid "8"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:31
#: ../source/2022/q_exercises/memory.rst:46
#: ../source/2022/q_exercises/memory.rst:68
#: ../source/2022/q_exercises/memory.rst:102
msgid "4"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:33
#: ../source/2022/q_exercises/memory.rst:35
#: ../source/2022/q_exercises/memory.rst:37
#: ../source/2022/q_exercises/memory.rst:48
#: ../source/2022/q_exercises/memory.rst:50
#: ../source/2022/q_exercises/memory.rst:52
#: ../source/2022/q_exercises/memory.rst:64
#: ../source/2022/q_exercises/memory.rst:66
#: ../source/2022/q_exercises/memory.rst:68
msgid "E"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:40
msgid "*Least-Recently Used*: #PageFault = 10"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:56
msgid "*Optimal*: #PageFault = 8"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:75
msgid ""
"Considerando uno schema di paginazione a 3 livelli in cui la tabella di "
"primo livello sia costituita da 4 K elementi, quella di secondo livello "
"da 2 K elementi e quella di terzo livello da 1 K elementi, si determini "
"il numero massimo di pagine gestibili all'interno dello spazio di "
"indirizzamento di un processo."
msgstr ""

#: ../source/2022/q_exercises/memory.rst:76
msgid ""
"Si consideri una sequenza di generazione di 4 processi, P4, P1, P2 e P3. "
"P1 e P2 hanno taglia 1MB, P3 ha taglia 2 MB e P4 ha taglia 4 MB. Il "
"sistema con multiprogrammazione è caratterizzato da:"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:79
msgid ""
"una memoria di lavoro di 7 MB di cui 1 MB sia riservato per il sistema "
"operativo"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:80
msgid "un meccanismo di allocazione dei processi basato su partizioni dinamiche."
msgstr ""

#: ../source/2022/q_exercises/memory.rst:82
msgid ""
"Assumendo che P4 non termini prima di P3, si determini quale deve essere "
"la relazione tra il tempo di completamento di P1 e P2 ed il tempo di "
"nascita di P3 affinché, e sotto quali condizioni, ognuno dei 4 processi "
"possa essere correttamente allocato in memoria all'atto della sua "
"creazione."
msgstr ""

#: ../source/2022/q_exercises/memory.rst:96
msgid "**P2**"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:97
msgid "**P3**"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:98
msgid "**P1**"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:100
msgid "**P4**"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:106
msgid "2"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:108
msgid "**MONITOR**"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:111
msgid ""
"Siano S_i e T_i rispettivamente l'istante di inizio e terminazione del "
"processo i"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:112
msgid "Vincoli:"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:114
msgid "S_4 < S_1 < S_2 < S_3"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:115
msgid "T_4 > S_3"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:117
msgid "Soluzione:"
msgstr ""

#: ../source/2022/q_exercises/memory.rst:119
msgid "S_3 > max(T_1, T_2)"
msgstr ""

#: ../source/2022/questions.rst:42
msgid "Esercizi di programmazione"
msgstr ""

#: ../source/2022/questions.rst:47
msgid ""
"Alcuni esercizi possono deliberatamente ammettere più di una "
"implementazione. Di conseguenza, le soluzioni proposte potrebbe non "
"essere le uniche ammissibili."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:2
msgid "1 - Riscaldamento"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:4
#: ../source/2022/q_exercises/programming.rst:11
msgid "Scrivere un programma che:"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:6
msgid ""
"prende una stringa da tastiera e la inserisce all’interno di un buffer "
"allocato dinamicamente nella heap da parte della funzione scanf()."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:7
msgid ""
"Copia poi tale stringa all’interno di un secondo buffer allocato sullo "
"stack della taglia necessaria a contenerla."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:8
msgid "Libera quindi il buffer allocato nella heap."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:9
msgid "Stampa sullo schermo la stringa copiata nel buffer allocato sullo stack."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:13
msgid ""
"prende una stringa passata come primo argomento (i.e. :code:`char "
"*argv[]`) al programma stesso quando questo viene eseguito."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:14
msgid ""
"Copia tale stringa all’interno di un buffer di dimensione fissa facendo "
"attenzione a non superare il limite imposto dalla taglia, e stamparla "
"quindi sullo schermo."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:15
msgid ""
"Rigira la stringa (primo carattere in ultima posizione, secondo carattere"
" in penultima posizione, ecc.) senza fare utilizzo di un ulteriore buffer"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:16
msgid "Stampa anche questa stringa sullo schermo."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:20
msgid "2 - Processi e threads"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:23
#: ../source/2022/q_exercises/programming.rst:29
#: ../source/2022/q_exercises/programming.rst:35
msgid "Scrivere un programma in C che:"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:25
#: ../source/2022/q_exercises/programming.rst:31
msgid ""
"prende inizialmente una stringa da input (può contenere anche spazi "
"bianchi) e la salva in un buffer"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:26
msgid ""
"fork-a un processo figlio che manda in stampa la stessa stringa acquisita"
" dal processo padre."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:27
msgid ""
"Il processo padre termina solo dopo che il processo figlio ha terminato "
"(verificare che tale ordine è rispettato stampando i PID dei processi)."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:32
msgid ""
"fork-are 2 processi figli che contribuiscono a stampare la stringa "
"inversa della stringa acquisita dal processo padre."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:33
msgid "Il processo padre termina solo dopo che i processi figli hanno terminato."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:37
msgid ""
"prende inizialmente N (a piacere) stringhe rappresentanti N directory "
"corrette"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:38
msgid ""
"fork-a quindi N processi che andranno ad eseguire il comando ls su una "
"directory differente."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:39
msgid "Il processo padre termina dopo i processi figli"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:41
msgid "Svolgere l'esercizio 2.1 utilizzando threads piuttosto che processi."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:42
msgid "Svolgere l'esercizio 2.2 utilizzando threads piuttosto che processi."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:48
msgid "3 - File"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:52
msgid ""
"Nei sistemi operativi UNIX, `/dev/urandom <https://man7.org/linux/man-"
"pages/man4/random.4.html>`_ è un dispositivo a caratteri (char device) "
"virtuale in grado di generare numeri casuali. Nello specifico, "
"l'operazione di lettura dal relativo file produce byte casuali. Scrivere "
"un programma C che genera un file con contenuto interamente randomico. Il"
" programma:"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:56
msgid ""
"prende come parametri da linea di comando: un numero *N* e una stringa "
"*S* da usare come nome del file da creare;"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:57
msgid "crea un file *S* contenente *N* byte randomici;"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:58
msgid ""
"utilizza il dispositivo /dev/random come sorgente di numeri pseudo-"
"casuali."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:60
msgid ""
"Dato un file binario contenente un sequenza di 2^15 interi di tipo "
"*short*, scrivere un programma che crea N processi o threads, i quali "
"leggono il contenuto del file ed individuano il valore minimo e massimo "
"contenuto nel file. Nel fornire una soluzione rispettare i seguenti "
"vincoli:"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:62
msgid "ciascun intero non può essere letto da più di un thread/processo;"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:63
msgid "ciascun thread/processo può leggere il medesimo intero al più una volta;"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:64
msgid ""
"ciascun thread/processo può allocare memoria nell'heap per al più 512 "
"byte;"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:65
msgid ""
"N è un parametro definito a tempo di compilazione o tramite linea di "
"comando;"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:66
msgid "N è minore o uguale a 8;"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:67
msgid ""
"è ammesso allocare di variabili globali (data) e locali (stack) per "
"memorizzare tipi primitivi (puntatori, int, short, char, long, etc.) per "
"al più 128 byte;"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:68
msgid "per generare il file utilizzare la soluzione dell'esercizio 3.1."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:70
msgid ""
"Scrivere un programma C *invert* che dato un file *A* ne inverte il "
"contenuto e lo memorizza in nuovo file *B*. Il programma deve:"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:72
msgid "riportare il contenuto di *A* in memoria;"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:73
msgid ""
"invertire la posizione di ciascun byte utilizzando un numero *N* di "
"thread/processi concorrenti;"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:74
msgid "scrivere il risultato in un nuovo file *B*;"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:75
msgid "prendere *A*, *B* e *N* come argomenti da linea di comando."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:77
msgid ""
"Si scriva il codice di una funzione C con la seguente interfaccia "
":code:`void tunnel(int descriptors[], int count)` tale che, se eseguita, "
"porti l'applicazione a gestire, per ogni file-descriptor dell'array "
"*descriptors* l'inoltro del flusso  dei dati in ingresso verso il canale "
"di standard-output dell'applicazione. Il parametro *count* indica di "
"quanti elementi è costituito l'array *descriptors*. L'inoltro dovrà "
"essere attuato in modo concorrente per i diversi canali."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:78
msgid ""
"Si scriva una funzione C con la seguente interfaccia :code:`void "
"file_check(char *file_name, int num_threads)`. Tale funzione dovrà "
"lanciare num_thread nuovi threads, in modo che ciascuno di essi legga "
"stringhe dallo standard input, e per ogni stringa letta verifichi "
"l'occorrenza di tale stringa all'interno *di ciascuna riga* del file il "
"cui path è identificato tramite il parametro file_name, e stampi la "
"stringa su standard output in caso affermativo."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:79
msgid ""
"Scrivere un programma C in cui dato un file *A*, una stringa *B* e un "
"intero *N*, vengano creati *N* thread/processi che cerchino se "
"all'interno del file *A* esiste una linea uguale a *B*."
msgstr ""

#~ msgid "# Scrivere un programma che:"
#~ msgstr ""

#~ msgid "8- Programmazione"
#~ msgstr ""

#~ msgid "Riscaldamento"
#~ msgstr ""

#~ msgid "Esercizi"
#~ msgstr ""

#~ msgid "Programmazione"
#~ msgstr ""

#~ msgid ""
#~ "*Il processo padre termina solo dopo "
#~ "che il processo figlio ha terminato "
#~ "(verificare che tale ordine è rispettato"
#~ " stampando i PID dei processi)."
#~ msgstr ""

#~ msgid "Svolgere l'esercizio 1 utilizzando threads piuttosto che processi."
#~ msgstr ""

#~ msgid "Svolgere l'esercizio 2 utilizzando threads piuttosto che processi."
#~ msgstr ""

#~ msgid ""
#~ "Si consideri uno scenario in cui "
#~ "uno scheduler Multilevel-feedback queue "
#~ "abbia 4 livelli di priorità, ed in"
#~ " cui il quanto di tempo assegnato "
#~ "ai processi al livello i sia di"
#~ " 1/2^i millisecondi. Si supponga che "
#~ "all'istante T0 nascano 2 processi A "
#~ "e B, entrambi CPU-bound. Il "
#~ "processo B richiede 10 millisecondi di"
#~ " tempo di CPU per completare la "
#~ "sua esecuzione. Si identifichi la durata"
#~ " massima (in termini di tempo di "
#~ "CPU) del processo A affinché il "
#~ "processo B possa completare la sua "
#~ "esecuzione entro il tempo T0+17 nei "
#~ "due casi in cui il primo processo"
#~ " ad essere schedulato in CPU sia "
#~ "A oppure B. Si supponga che il "
#~ "tempo di CPU per i context switch"
#~ " e per l'esecuzione dello scheduler "
#~ "sia nullo."
#~ msgstr ""

#~ msgid ""
#~ "Si consideri uno scenario in cui "
#~ "al tempo T0 nasca un processo P0"
#~ " puramente CPU-bound di durata (tempo"
#~ " di CPU) pari a 10 secondi ed"
#~ " al tempo T0 + 3 secondi P0 "
#~ "origini un altro processo P1 puramente"
#~ " CPU-bound di durata (tempo di "
#~ "CPU) pari a 6 secondi. Supponendo "
#~ "che le durate dei processi siano "
#~ "note al tempo della loro generazione,"
#~ " e che il tempo di CPU per "
#~ "eseguire uno scheduler sia trascurabile. "
#~ "si calcoli il tempo massimo di "
#~ "completamento del processo P1 nel caso"
#~ " in cui il sistema abbia come "
#~ "scheduler Shortest Process Next oppure "
#~ "Shortest-Remaining-Time Next."
#~ msgstr ""

#~ msgid "6 - I/O Management"
#~ msgstr ""

#~ msgid "7 - File management"
#~ msgstr ""

#~ msgid "3 - Scheduling"
#~ msgstr ""

#~ msgid ""
#~ "Nei sistemi operativi UNIX, `/dev/urandom "
#~ "<https://man7.org/linux/man-pages/man4/random.4.html>`_ è"
#~ " un dispositivo a caratteri (char "
#~ "device) virtuale in grado di generare"
#~ " numeri casuali."
#~ msgstr ""

#~ msgid ""
#~ "Nello specifico, l'operazione di lettura "
#~ "dal relativo file produce byte casuali."
#~ " Scrivere un programma C che genera"
#~ " un file con contenuto interamente "
#~ "randomico. Il programma:"
#~ msgstr ""

#~ msgid "..comment:"
#~ msgstr ""

#~ msgid ""
#~ "**SOLUZIONE**: `Github "
#~ "<https://github.com/SistemiOperativi/c_examples/tree/main/ex_8_3>`__"
#~ msgstr ""

#~ msgid ""
#~ "è ammesso allocare di variabili globali"
#~ " (data) e locali (stack) per "
#~ "memorizzare tipi primitivi (puntatori, int,"
#~ " short, char, long, etc.) per al "
#~ "più 128 byte."
#~ msgstr ""

#~ msgid ""
#~ "Per generare il file è possibile "
#~ "utilizzare la soluzione dell'esercizio 1."
#~ msgstr ""

#~ msgid "scrivere il risultato in un nuovo file *B*."
#~ msgstr ""

#~ msgid ""
#~ "*A*, *B* e *N* sono parametri che"
#~ " il programma deve acquisire da linea"
#~ " di comando."
#~ msgstr ""

