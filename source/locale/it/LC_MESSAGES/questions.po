# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2021, Romolo Marotta
# This file is distributed under the same license as the Sistemi Operativi
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Sistemi Operativi \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-09-26 12:01+0200\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../source/questions.rst:2
msgid "Esercizi di preparazione"
msgstr ""

#: ../source/questions.rst:4
msgid ""
"In questa sezione vengono riportate alcuni esercizi/domande che possono "
"essere utilizzate come preparazione all'esame."
msgstr ""

#: ../source/questions.rst:8
msgid "Domande"
msgstr ""

#: ../source/questions.rst:21
msgid "Esercizi"
msgstr ""

#: ../source/questions.rst:26
msgid ""
"Alcuni esercizi possono deliberatamente ammettere più di una soluzione in"
" funzione delle assunzioni fatte durante lo svolgimento. Di conseguenza, "
"le soluzioni proposte potrebbe non essere le uniche ammissibili."
msgstr ""

#~ msgid "Compara, mostrando vantaggi e svantaggi, le seguenti"
#~ msgstr ""

#~ msgid ""
#~ "due soluzioni architetturali per un "
#~ "sistema operativo: (1) \"execution within "
#~ "process\", in cui ciascuna system call"
#~ " e' eseguita all'interno del processo. "
#~ "(2) \"process based\" (microkernel) in "
#~ "cui le system call sono eseguite "
#~ "da processi sperarati."
#~ msgstr ""

#~ msgid "Che cosa e' un buddy system? che proprieta' hanno gli indirizzi"
#~ msgstr ""

#~ msgid "delle zone di memoria ritornati dal buddy system?"
#~ msgstr ""

#~ msgid "Considera un buddy system. Supponi che le richieste di"
#~ msgstr ""

#~ msgid ""
#~ "allocazione siano per porzioni di "
#~ "memoria la cui grandezza sia "
#~ "uniformemente distribuita tra 64bytes e "
#~ "512Kbytes. Sai stimare mediamente qual'e' "
#~ "la frazione di memoria che si "
#~ "perde in frammentazione interna ed "
#~ "esterna?"
#~ msgstr ""

#~ msgid ""
#~ "# Descrivi la tecniche di paginazione"
#~ " e segmentazione mostrando vantaggi e "
#~ "svantaggi di ciascuna e il loro "
#~ "rapporto con il concetto di "
#~ "frammentazione. # Mostra lo schema di"
#~ " paginazione a due livelli e il "
#~ "processo di traduzione di un indirizzo"
#~ " virtuale in fisico. Quali sono i "
#~ "vantaggi e gli svantaggi nell'uso di "
#~ "tale schema? # Che cosa e' un "
#~ "buddy system? che proprieta' hanno gli"
#~ " indirizzi delle zone di memoria "
#~ "ritornati dal buddy system? # Considera"
#~ " un buddy system. Supponi che le "
#~ "richieste di allocazione siano per "
#~ "porzioni di memoria la cui grandezza "
#~ "sia uniformemente distribuita tra 64bytes "
#~ "e 512Kbytes. Sai stimare mediamente "
#~ "qual'e' la frazione di memoria che "
#~ "si perde in frammentazione interna ed"
#~ " esterna?"
#~ msgstr ""

#~ msgid "Descrivi una inverted page table e mostra i vantaggi e gli"
#~ msgstr ""

#~ msgid "svantaggi di tale soluzione."
#~ msgstr ""

#~ msgid "A cosa serve il translation lookside buffer? come interviene nel"
#~ msgstr ""

#~ msgid "processo di traduzione di un indirizzo virtuale in uno fisico"
#~ msgstr ""

#~ msgid "mostra lo schema di traduzione di indirizzo virtuale in fisico per"
#~ msgstr ""

#~ msgid "un sistema che adotta segmentazione, paginazione e TLB."
#~ msgstr ""

#~ msgid "che significa che un sistema operativo ha un modello SAS o MAS?"
#~ msgstr ""

#~ msgid "Trashing, load control e mid-term scheduler. Come sono correlati"
#~ msgstr ""

#~ msgid ""
#~ "questi concetti? Qual'e' l'obiettivo di "
#~ "un mid-term scheduler. Fai un "
#~ "esempio di politica per un mid-"
#~ "term scheduler."
#~ msgstr ""

#~ msgid "cpu-scheduler: quali sono i criteri con cui viene valutata la"
#~ msgstr ""

#~ msgid "qualita' di cpu-scheduler?"
#~ msgstr ""

#~ msgid ""
#~ "# Descrivi il concetto di processo. "
#~ "Quali sono i possibili stati di un"
#~ " processo? # Spiegare la differenza "
#~ "tra il concetto di processo e "
#~ "thread. # Descrivi il concetto di "
#~ "mode switch e di process switch."
#~ msgstr ""

#~ msgid ""
#~ "#. Trashing, load control e mid-"
#~ "term scheduler. Come sono correlati "
#~ "questi concetti? Qual'e' l'obiettivo di "
#~ "un mid-term scheduler. Fai un "
#~ "esempio di politica per un mid-"
#~ "term scheduler. #. Cpu-scheduler: quali"
#~ " sono i criteri con cui viene "
#~ "valutata la qualita' di cpu-scheduler?"
#~ msgstr ""

#~ msgid ""
#~ "#. Trashing, load control e mid-"
#~ "term scheduler. Come sono correlati "
#~ "questi concetti? Qual'e' l'obiettivo di "
#~ "un mid-term scheduler. Fai un "
#~ "esempio di politica per un mid-"
#~ "term scheduler."
#~ msgstr ""

#~ msgid ""
#~ "#. Cpu-scheduler: quali sono i "
#~ "criteri con cui viene valutata la "
#~ "qualita' di cpu-scheduler?"
#~ msgstr ""

#~ msgid ""
#~ "questi concetti? Qual'e' l'obiettivo di "
#~ "un mid-term scheduler. Fai un "
#~ "esempio di politica per un mid-"
#~ "term scheduler. * Cpu-scheduler: quali"
#~ " sono i criteri con cui viene "
#~ "valutata la qualita' di cpu-scheduler?"
#~ msgstr ""

#~ msgid ""
#~ "Trashing, load control e mid-term "
#~ "scheduler. Come sono correlati questi "
#~ "concetti? Qual'e' l'obiettivo di un "
#~ "mid-term scheduler. Fai un esempio di"
#~ " politica per un mid-term scheduler."
#~ msgstr ""

#~ msgid ""
#~ "Trashing, load control e mid-term "
#~ "scheduler. Come sono correlati questi "
#~ "concetti? Qual'è l'obiettivo di un "
#~ "mid-term scheduler. Fai un esempio di"
#~ " politica per un mid-term scheduler."
#~ msgstr ""

#~ msgid ""
#~ "Cpu-scheduler: quali sono i criteri "
#~ "con cui viene valutata la qualita' "
#~ "di cpu-scheduler?"
#~ msgstr ""

#~ msgid "This is a numbered list."
#~ msgstr ""

#~ msgid "It has two items too."
#~ msgstr ""

#~ msgid ""
#~ "questi concetti? Qual'è l'obiettivo di "
#~ "un mid-term scheduler. Fai un "
#~ "esempio di politica per un mid-"
#~ "term scheduler."
#~ msgstr ""

#~ msgid "Cpu-scheduler: quali sono i criteri con cui viene valutata la"
#~ msgstr ""

#~ msgid ""
#~ "#. Descrivi il concetto di processo. "
#~ "Quali sono i possibili stati di un"
#~ " processo? #. Spiegare la differenza "
#~ "tra il concetto di processo e "
#~ "thread. #. Descrivi il concetto di "
#~ "mode switch e di process switch."
#~ msgstr ""

#~ msgid ""
#~ "#. Descrivi la tecniche di paginazione"
#~ " e segmentazione mostrando vantaggi e "
#~ "svantaggi di ciascuna e il loro "
#~ "rapporto con il concetto di "
#~ "frammentazione. #. Mostra lo schema di"
#~ " paginazione a due livelli e il "
#~ "processo di traduzione di un indirizzo"
#~ " virtuale in fisico. Quali sono i "
#~ "vantaggi e gli svantaggi nell'uso di "
#~ "tale schema? #. Che cosa e' un "
#~ "buddy system? che proprieta' hanno gli"
#~ " indirizzi delle zone di memoria "
#~ "ritornati dal buddy system? #. Considera"
#~ " un buddy system. Supponi che le "
#~ "richieste di allocazione siano per "
#~ "porzioni di memoria la cui grandezza "
#~ "sia uniformemente distribuita tra 64bytes "
#~ "e 512Kbytes. Sai stimare mediamente "
#~ "qual'e' la frazione di memoria che "
#~ "si perde in frammentazione interna ed"
#~ " esterna? #. A cosa serve il "
#~ "translation lookside buffer? come interviene"
#~ " nel processo di traduzione di un "
#~ "indirizzo virtuale in uno fisico #. "
#~ "mostra lo schema di traduzione di "
#~ "indirizzo virtuale in fisico per un "
#~ "sistema che adotta segmentazione, paginazione"
#~ " e TLB."
#~ msgstr ""

#~ msgid ""
#~ "1. Descrivi il concetto di interrupt "
#~ "e mostra alcuni aspetti dei sistemi "
#~ "operativi in cui ritieni che tale "
#~ "concetto abbia un ruolo rilevante. 1."
#~ " Descrivi le principali strutture dati "
#~ "che un sistema operativo gestisce."
#~ msgstr ""

#~ msgid ""
#~ "Descrivi il concetto di interrupt e "
#~ "mostra alcuni aspetti dei sistemi "
#~ "operativi in cui ritieni che tale "
#~ "concetto abbia un ruolo rilevante."
#~ msgstr ""

#~ msgid ""
#~ "Descrivi le principali strutture dati "
#~ "che un sistema operativo gestisce."
#~ msgstr ""

#~ msgid "Spiegare la differenza tra il concetto di processo e thread."
#~ msgstr ""

#~ msgid ""
#~ "Descrivi la tecniche di paginazione e"
#~ " segmentazione mostrando vantaggi e "
#~ "svantaggi di ciascuna e il loro "
#~ "rapporto con il concetto di "
#~ "frammentazione."
#~ msgstr ""

#~ msgid ""
#~ "Che cosa e' un buddy system? che"
#~ " proprieta' hanno gli indirizzi delle "
#~ "zone di memoria ritornati dal buddy "
#~ "system?"
#~ msgstr ""

#~ msgid ""
#~ "Considera un buddy system. Supponi che"
#~ " le richieste di allocazione siano "
#~ "per porzioni di memoria la cui "
#~ "grandezza sia uniformemente distribuita tra"
#~ " 64bytes e 512Kbytes. Sai stimare "
#~ "mediamente qual'e' la frazione di "
#~ "memoria che si perde in frammentazione"
#~ " interna ed esterna?"
#~ msgstr ""

#~ msgid ""
#~ "A cosa serve il translation lookside "
#~ "buffer? come interviene nel processo di"
#~ " traduzione di un indirizzo virtuale "
#~ "in uno fisico"
#~ msgstr ""

#~ msgid ""
#~ "mostra lo schema di traduzione di "
#~ "indirizzo virtuale in fisico per un "
#~ "sistema che adotta segmentazione, paginazione"
#~ " e TLB."
#~ msgstr ""

#~ msgid ""
#~ "#. Che cosa è un buddy system? "
#~ "..#. Considera un buddy system. Supponi"
#~ " che le richieste di allocazione "
#~ "siano per porzioni di memoria la "
#~ "cui grandezza sia uniformemente distribuita"
#~ " tra 64bytes e 512Kbytes. Sai stimare"
#~ " mediamente qual è la frazione di "
#~ "memoria che si perde in frammentazione"
#~ " interna ed esterna?"
#~ msgstr ""

#~ msgid ""
#~ "..#. Trashing, load control e mid-"
#~ "term scheduler. Come sono correlati "
#~ "questi concetti? Qual'è l'obiettivo di "
#~ "un mid-term scheduler. Fai un "
#~ "esempio di politica per un mid-"
#~ "term scheduler. #. Cpu-scheduler: quali"
#~ " sono i criteri di valutazione di "
#~ "un cpu-scheduler?"
#~ msgstr ""

#~ msgid ""
#~ "..#. Considera un buddy system. Supponi"
#~ " che le richieste di allocazione "
#~ "siano per porzioni di memoria la "
#~ "cui grandezza sia uniformemente distribuita"
#~ " tra 64bytes e 512Kbytes. Sai stimare"
#~ " mediamente qual è la frazione di "
#~ "memoria che si perde in frammentazione"
#~ " interna ed esterna?"
#~ msgstr ""

#~ msgid "Introduzione"
#~ msgstr ""

#~ msgid "Processi e thread"
#~ msgstr ""

#~ msgid "Scheduling"
#~ msgstr ""

#~ msgid "Gestione della memoria"
#~ msgstr ""

#~ msgid "Domande di preparazione"
#~ msgstr ""

#~ msgid ""
#~ "In questa sezione vengono riportate "
#~ "alcune domande che possono essere "
#~ "utilizzate come preparazione all'esame."
#~ msgstr ""

#~ msgid "Cpu-scheduler: quali sono i criteri di valutazione di un cpu-scheduler?"
#~ msgstr ""

#~ msgid "4 - Gestione della memoria"
#~ msgstr ""

#~ msgid "Cos'è un'istruzione Read-Modify-Write."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere le politiche First-Come-"
#~ "First-Served e Shortest-Seek-Time-"
#~ "First per disk scheduling e spiegarne"
#~ " le differenze."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere le politiche First-Come-"
#~ "First-Served e Shortest-Seek-Time-"
#~ "First per disk scheduling e spiegarne"
#~ " le vantaggi e svantaggi."
#~ msgstr ""

#~ msgid "Quali sono gli obiettivi princiapli di un sistema operativo?"
#~ msgstr ""

#~ msgid ""
#~ "Descrivere 3 servizi di sistema "
#~ "operativo che ne rendono conveniente "
#~ "l'utilizzo. Perché è sconveniente che "
#~ "siano forniti da programmi user?."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere 3 servizi di sistema "
#~ "operativo e spiegare perché sono "
#~ "convenienti per gli utenti. Inoltre, "
#~ "perché è sconveniente che siano forniti"
#~ " da programmi user?."
#~ msgstr ""

#~ msgid ""
#~ "Quando un thread viene creato, cosa "
#~ "è condiviso tra thread parent e "
#~ "child?"
#~ msgstr ""

#~ msgid "Gli spinlock sono appropriati in un sistema single-core?"
#~ msgstr ""

#~ msgid ""
#~ "Calcolare lo speedup ottenibile tramite "
#~ "la sola ottimizzazione a) con 2 e"
#~ " 4 core, tramite la sola "
#~ "ottimizzazione b) e l'applicazione congiunta"
#~ " di a) e b) con 2 e 4 "
#~ "core. Infine, riportare lo speedup "
#~ "massimo raggiungibile tramite ottimizzazione "
#~ "a) e b)."
#~ msgstr ""

#~ msgid ""
#~ "Si consideri uno scenario con 4 "
#~ "processi {P1,..., P4} CPU-bound e "
#~ "generati in sequenza a partire da "
#~ "P1 a P4 con ritardi trascurabili. "
#~ "Le cui richieste di uso della CPU"
#~ " per completare la loro esecuzione "
#~ "sono tali che Pi richiede 1/i sec."
#~ " Considerando che il ritardo di "
#~ "context-switch sia trascurabile e che "
#~ "RR abbia una time slice pari a "
#~ "125ms, si calcoli per gli algoritmi "
#~ "FCFS, SPN e RR il tempo di "
#~ "primo accesso alla CPU e il tempo"
#~ " di completamento per ciascun processo."
#~ msgstr ""

#~ msgid ""
#~ "Si consideri il caso di memoria "
#~ "virtuale basata su paginazione a più "
#~ "livelli, indirizzi logici e fisici a "
#~ "40 bit, pagine di 4MB e tabelle"
#~ " pari alla dimensione di una pagina."
#~ msgstr ""

#~ msgid "Quanti bit servono per identificare una pagina?"
#~ msgstr ""

#~ msgid ""
#~ "identificare la struttura dell'indirizzo e "
#~ "l'utilizzo dei bit nel suddetto schema"
#~ " di paginazione;"
#~ msgstr ""

#~ msgid ""
#~ "il numero massimo di frame di "
#~ "memoria impegnati da un processo nel "
#~ "caso in cui il numero delle "
#~ "tabelle a qualsiasi livello correntemente "
#~ "usate per quel processo in suddetto "
#~ "schema di paginazione sia pari a "
#~ "10."
#~ msgstr ""

#~ msgid ""
#~ "Qual è il numero massimo di frame"
#~ " di memoria impegnati da un processo"
#~ " nel caso in cui il numero "
#~ "delle tabelle a qualsiasi livello "
#~ "correntemente usate per quel processo in"
#~ " suddetto schema di paginazione sia "
#~ "pari a 10."
#~ msgstr ""

#~ msgid ""
#~ "Calcolare la latenza massima e minima"
#~ " considerando che: * il tempo medio"
#~ " di accesso ad un blocco è "
#~ "10ms; * l'accesso ad una chiave "
#~ "dell'indice in ram è pari a 1ms."
#~ msgstr ""

#~ msgid "Si consideri un file system con allocazione indicizzata."
#~ msgstr ""

#~ msgid ""
#~ "Nei sistemi operitvi UNIX, `/dev/urandom "
#~ "<https://man7.org/linux/man-pages/man4/random.4.html>` è"
#~ " un dispositivo a caratteri (char "
#~ "device) virtuale in grado di generare"
#~ " numeri casuali. Nello specifico, "
#~ "l'operazione di lettura dal relativo "
#~ "file produce byte casuali. Scrivere un"
#~ " programma C che genera un file "
#~ "con contenuto interamente randomico. Il "
#~ "programma:"
#~ msgstr ""

#~ msgid ""
#~ "*A*, *B* e *N* sono parametri che"
#~ " il programma deve acquisiti da linea"
#~ " di comando."
#~ msgstr ""

#~ msgid "Descrivere le caratteristiche saliente del file system UNIX"
#~ msgstr ""

#~ msgid ""
#~ "Si consideri uno scenario con 4 "
#~ "processi {P1,..., P4} CPU-bound e "
#~ "generati in sequenza a partire da "
#~ "P1 a P4 con ritardi trascurabili. "
#~ "Il processo Pi richiede 1/i secondi "
#~ "di CPU per completare la propria "
#~ "esecuzione. Considerando che il ritardo "
#~ "di context-switch sia trascurabile e "
#~ "che RR abbia una time slice pari"
#~ " a 125ms, si calcoli per gli "
#~ "algoritmi FCFS, SPN e RR il tempo"
#~ " di primo accesso alla CPU e il"
#~ " tempo di completamento per ciascun "
#~ "processo."
#~ msgstr ""

#~ msgid ""
#~ "#. Scriva il codice di una "
#~ "funzione C con la seguente interfaccia"
#~ " :code:`void tunnel(int descriptors[], int "
#~ "count)` tale che, se eseguita, porti "
#~ "l'applicazione a gestire, per ogni "
#~ "file-descriptor dell'array *descriptors* "
#~ "l'inoltro del flusso  dei dati in "
#~ "ingresso verso il canale di standard-"
#~ "output dell'applicazione. Il parametro *count*"
#~ " indica di quanti elementi e' "
#~ "costituito l'array *descriptors*. L'inoltro "
#~ "dovrà essere attuato in modo concorrente"
#~ " per i diversi canali."
#~ msgstr ""

#~ msgid ""
#~ "#. Descrivere le principali caratteristiche"
#~ " di un sistema batch e di un"
#~ " sistema batch multiprogrammato, discutendo "
#~ "anche in modo comparativo i vantaggi "
#~ "o svantaggi dell’uno verso l’altro."
#~ msgstr ""

#~ msgid ""
#~ "#. Descrivere le principali caratteristiche"
#~ " di un sistema batch e di un"
#~ " sistema batch multiprogrammato, discutendo "
#~ "anche in modo comparativo i vantaggi "
#~ "o svantaggi dell'uno verso l'altro."
#~ msgstr ""

#~ msgid ""
#~ "#. Si descrivano gli scheduler di "
#~ "CPU Shortest-Process-Next (SPN) e "
#~ "la sua variante Shortest–Remaining-Time-"
#~ "Next (SRTN), evidenziandone i vantaggi e"
#~ " gli svantaggi."
#~ msgstr ""

#~ msgid ""
#~ "#. Descrivere la struttura e l'utilizzo"
#~ " della tabella delle pagine e la "
#~ "relazione tra questa ed i componenti "
#~ "hardware presenti su una architettura di"
#~ " processore convenzionale."
#~ msgstr ""

#~ msgid ""
#~ "#. Si consideri una sequenza di "
#~ "generazione di 4 processi, P4, P1, "
#~ "P2 e P3. P1 e P2 hanno "
#~ "taglia 1MB, P3 ha taglia 2 MB "
#~ "e P4 ha taglia 4 MB. Il "
#~ "sistema con multiprogrammazione è "
#~ "caratterizzato da una memoria di lavoro"
#~ " di 7 MB di cui 1 MB sia"
#~ " riservato per il sistema operativo, "
#~ "un meccanismo di allocazione dei "
#~ "processi basato su partizioni dinamiche. "
#~ "Assumendo che P4 non termini prima "
#~ "di P3, si determini quale deve "
#~ "essere la relazione tra il tempo "
#~ "di completamento di P1 e P2 ed "
#~ "il tempo di nascita di P3 "
#~ "affinchè, e sotto quali condizioni, "
#~ "ognuno dei 4 processi posssa essere "
#~ "correttamente allocato in memoria all’atto "
#~ "della sua creazione."
#~ msgstr ""

#~ msgid ""
#~ "#. Si scriva il codice di una "
#~ "funzione C con la seguente interfaccia"
#~ " :code:`void tunnel(int descriptors[], int "
#~ "count)` tale che, se eseguita, porti "
#~ "l'applicazione a gestire, per ogni "
#~ "file-descriptor dell'array *descriptors* "
#~ "l'inoltro del flusso  dei dati in "
#~ "ingresso verso il canale di standard-"
#~ "output dell'applicazione. Il parametro *count*"
#~ " indica di quanti elementi e' "
#~ "costituito l'array *descriptors*. L'inoltro "
#~ "dovrà essere attuato in modo concorrente"
#~ " per i diversi canali. #. Si "
#~ "scriva una funzione C con la "
#~ "seguente interfaccia :code:`void file_check(char "
#~ "*file_name, int num_threads)`. Tale funzione"
#~ " dovrà lanciare num_thread nuovi threads,"
#~ " in modo che ciascuno di essi "
#~ "legga stringhe dallo standard input, e"
#~ " per ogni stringa letta verifichi "
#~ "l'occorrenza di tale stringa all'interno "
#~ "del file il cui path e' "
#~ "identificato tramite il parametro file_name,"
#~ " e stampi la stringa su standard "
#~ "output in caso affermativo."
#~ msgstr ""

#~ msgid ""
#~ "Si scriva il codice di una "
#~ "funzione C con la seguente interfaccia"
#~ " :code:`void tunnel(int descriptors[], int "
#~ "count)` tale che, se eseguita, porti "
#~ "l'applicazione a gestire, per ogni "
#~ "file-descriptor dell'array *descriptors* "
#~ "l'inoltro del flusso  dei dati in "
#~ "ingresso verso il canale di standard-"
#~ "output dell'applicazione. Il parametro *count*"
#~ " indica di quanti elementi e' "
#~ "costituito l'array *descriptors*. L'inoltro "
#~ "dovrà essere attuato in modo concorrente"
#~ " per i diversi canali."
#~ msgstr ""

#~ msgid ""
#~ "Si scriva il codice di una "
#~ "funzione C con la seguente interfaccia"
#~ " :code:`void tunnel(int descriptors[], int "
#~ "count)` tale che, se eseguita, porti "
#~ "l'applicazione a gestire, per ogni "
#~ "file-descriptor dell'array *descriptors* "
#~ "l'inoltro del flusso  dei dati in "
#~ "ingresso verso il canale di standard-"
#~ "output dell'applicazione."
#~ msgstr ""

#~ msgid ""
#~ "Il parametro *count* indica di quanti"
#~ " elementi e' costituito l'array "
#~ "*descriptors*. L'inoltro dovrà essere attuato"
#~ " in modo concorrente per i diversi"
#~ " canali."
#~ msgstr ""

#~ msgid ""
#~ "Si scriva una funzione C con la"
#~ " seguente interfaccia :code:`void file_check(char"
#~ " *file_name, int num_threads)`. Tale "
#~ "funzione dovrà lanciare num_thread nuovi "
#~ "threads, in modo che ciascuno di "
#~ "essi legga stringhe dallo standard "
#~ "input, e per ogni stringa letta "
#~ "verifichi l'occorrenza di tale stringa "
#~ "all'interno del file il cui path "
#~ "e' identificato tramite il parametro "
#~ "file_name, e stampi la stringa su "
#~ "standard output in caso affermativo."
#~ msgstr ""

#~ msgid ""
#~ "4. Si scriva il codice di una "
#~ "funzione C con la seguente interfaccia"
#~ " :code:`void tunnel(int descriptors[], int "
#~ "count)` tale che, se eseguita, porti "
#~ "l'applicazione a gestire, per ogni "
#~ "file-descriptor dell'array *descriptors* "
#~ "l'inoltro del flusso  dei dati in "
#~ "ingresso verso il canale di standard-"
#~ "output dell'applicazione. Il parametro *count*"
#~ " indica di quanti elementi e' "
#~ "costituito l'array *descriptors*. L'inoltro "
#~ "dovrà essere attuato in modo concorrente"
#~ " per i diversi canali. #. Si "
#~ "scriva una funzione C con la "
#~ "seguente interfaccia :code:`void file_check(char "
#~ "*file_name, int num_threads)`. Tale funzione"
#~ " dovrà lanciare num_thread nuovi threads,"
#~ " in modo che ciascuno di essi "
#~ "legga stringhe dallo standard input, e"
#~ " per ogni stringa letta verifichi "
#~ "l'occorrenza di tale stringa all'interno "
#~ "del file il cui path e' "
#~ "identificato tramite il parametro file_name,"
#~ " e stampi la stringa su standard "
#~ "output in caso affermativo."
#~ msgstr ""

#~ msgid ""
#~ "#. Si consideri uno scenario con 4"
#~ " processi {P1,..., P4} CPU-bound e"
#~ " generati in sequenza a partire da"
#~ " P1 a P4 con ritardi trascurabili."
#~ " Il processo Pi richiede 1/i secondi"
#~ " di CPU per completare la propria "
#~ "esecuzione. Considerando che il ritardo "
#~ "di context-switch sia trascurabile e "
#~ "che RR abbia una time slice pari"
#~ " a 125ms, si calcoli per gli "
#~ "algoritmi FCFS, SPN e RR il tempo"
#~ " di primo accesso alla CPU e il"
#~ " tempo di completamento per ciascun "
#~ "processo. #. Si consideri uno scenario"
#~ " in cui uno scheduler Multilevel-"
#~ "feedback queue abbia 4 livelli di "
#~ "priorità, ed in cui il quanto di"
#~ " tempo assegnato ai processi al "
#~ "livello i sia di 1/2^i millicondo. "
#~ "Si supponga che all'istante T0 nascano"
#~ " 2 processi A e B, entrambi "
#~ "CPU-bound. Il processo B richiede 10"
#~ " millisecondi di tempo di CPU per "
#~ "completare la sua esecuzione. Si "
#~ "identifichi la durata massima (in "
#~ "termini di tempo di CPU) del "
#~ "processo A affinché il processo B "
#~ "possa completare la sua esecuzione entro"
#~ " il tempo T0+17 nei due casi in"
#~ " cui il primo processo ad essere "
#~ "schedulato in CPU sia A oppure B."
#~ " Si supponga che il tempo di "
#~ "CPU per i context switch e per "
#~ "l'esecuzione dello scheduler sia nullo. "
#~ "#. Si consideri uno scenario in "
#~ "cui al tempo T0 nasca un processo"
#~ " P0 puramente CPU-bound di durata "
#~ "(tempo di CPU) pari a 10 secondi"
#~ " ed al tempo T0 + 3 secondi "
#~ "P0 origini un altro processo P1 "
#~ "puramente CPU-bound di durata (tempo "
#~ "di CPU) pari a 6 secondi. "
#~ "Supponendo che le durate dei processi"
#~ " siano note al tempo della loro "
#~ "generazione, e che il tempo di CPU"
#~ " per eseguire uno scheduler sia "
#~ "trascurabile. si calcoli il tempo "
#~ "massimo di completamento del processo P1"
#~ " nel caso in cui il sistema "
#~ "abbia come scheduler Shortest Process "
#~ "Next oppure Shortest-Remaining-Time "
#~ "Next."
#~ msgstr ""

#~ msgid "**Show/Hide Code**"
#~ msgstr ""

#~ msgid "**Show/Hide Solution**"
#~ msgstr ""

#~ msgid "This is a test"
#~ msgstr ""

#~ msgid "*FIFO*"
#~ msgstr ""

#~ msgid "*0*"
#~ msgstr ""

#~ msgid "*9*"
#~ msgstr ""

#~ msgid "*3*"
#~ msgstr ""

#~ msgid "*5*"
#~ msgstr ""

#~ msgid "*7*"
#~ msgstr ""

#~ msgid "*6*"
#~ msgstr ""

#~ msgid "*8*"
#~ msgstr ""

#~ msgid "*4*"
#~ msgstr ""

#~ msgid "*Least-Recently Used*"
#~ msgstr ""

#~ msgid "*Optimal*"
#~ msgstr ""

#~ msgid "**Mostra/Nascondi Solutione**"
#~ msgstr ""

#~ msgid ""
#~ "Si consideri una sequenza di generazione"
#~ " di 4 processi, P4, P1, P2 e"
#~ " P3. P1 e P2 hanno taglia 1MB,"
#~ " P3 ha taglia 2 MB e P4 "
#~ "ha taglia 4 MB. Il sistema con "
#~ "multiprogrammazione è caratterizzato da una"
#~ " memoria di lavoro di 7 MB di"
#~ " cui 1 MB sia riservato per il"
#~ " sistema operativo, un meccanismo di "
#~ "allocazione dei processi basato su "
#~ "partizioni dinamiche. Assumendo che P4 "
#~ "non termini prima di P3, si "
#~ "determini quale deve essere la relazione"
#~ " tra il tempo di completamento di "
#~ "P1 e P2 ed il tempo di "
#~ "nascita di P3 affinchè, e sotto "
#~ "quali condizioni, ognuno dei 4 processi"
#~ " posssa essere correttamente allocato in"
#~ " memoria all’atto della sua creazione."
#~ msgstr ""

#~ msgid ""
#~ "*SOLUZIONE*: `Github "
#~ "<https://github.com/SistemiOperativi/c_examples/tree/main/ex_8_3>`__"
#~ msgstr ""

#~ msgid "**P2"
#~ msgstr ""

#~ msgid "Vincoli: T_4 > S_3"
#~ msgstr ""

#~ msgid "S_3 > max(T_1, T_2)"
#~ msgstr ""

#~ msgid "Vincoli: * S_4 < S_1 < S_2 * T_4 > S_3"
#~ msgstr ""

#~ msgid "Si decriva il metodo di allocazione dei file a catena."
#~ msgstr ""

#~ msgid ""
#~ "Si consideri uno scenario in cui "
#~ "uno scheduler Multilevel-feedback queue "
#~ "abbia 4 livelli di priorità, ed in"
#~ " cui il quanto di tempo assegnato "
#~ "ai processi al livello i sia di"
#~ " 1/2^i millicondo. Si supponga che "
#~ "all'istante T0 nascano 2 processi A "
#~ "e B, entrambi CPU-bound. Il "
#~ "processo B richiede 10 millisecondi di"
#~ " tempo di CPU per completare la "
#~ "sua esecuzione. Si identifichi la durata"
#~ " massima (in termini di tempo di "
#~ "CPU) del processo A affinché il "
#~ "processo B possa completare la sua "
#~ "esecuzione entro il tempo T0+17 nei "
#~ "due casi in cui il primo processo"
#~ " ad essere schedulato in CPU sia "
#~ "A oppure B. Si supponga che il "
#~ "tempo di CPU per i context switch"
#~ " e per l'esecuzione dello scheduler "
#~ "sia nullo."
#~ msgstr ""

#~ msgid ""
#~ "Considerando uno schema di paginazione a"
#~ " 3 livelli in cui la tabella di"
#~ " primo livello sia costituita da 4"
#~ " K elementi, quella di secondo "
#~ "livello da 2 K elementi e quella"
#~ " di terzo livello da 1 K "
#~ "elementi, si determini il numero massimo"
#~ " di pagine gestibili all’interno dello "
#~ "spazio di indirizzamento di un processo."
#~ msgstr ""

#~ msgid ""
#~ "Assumendo che P4 non termini prima "
#~ "di P3, si determini quale deve "
#~ "essere la relazione tra il tempo "
#~ "di completamento di P1 e P2 ed "
#~ "il tempo di nascita di P3 "
#~ "affinchè, e sotto quali condizioni, "
#~ "ognuno dei 4 processi posssa essere "
#~ "correttamente allocato in memoria all’atto "
#~ "della sua creazione."
#~ msgstr ""

#~ msgid "S_4 < S_1 < S_2"
#~ msgstr ""

#~ msgid "Soluzione: * S_3 > max(T_1, T_2)"
#~ msgstr ""

#~ msgid ""
#~ "memorizzato su un dispositvo di massa,"
#~ " la cui taglia di un blocco è"
#~ " pari a 4096 record."
#~ msgstr ""

#~ msgid "128 entry per acesso diretto;"
#~ msgstr ""

#~ msgid ""
#~ "Si consideri inoltre senario dove un "
#~ "processo P apra un file F "
#~ "(attualmente non in uso da parte "
#~ "di alcun processo) e poi esegua 2"
#~ " fork(). Indicare il numero delle "
#~ "sessioni di I/O verso  il file F"
#~ " a valle dell’esecusione delle 2 "
#~ "fork() da parte di P."
#~ msgstr ""

#~ msgid ""
#~ "Nei sistemi operitvi UNIX, `/dev/urandom "
#~ "<https://man7.org/linux/man-pages/man4/random.4.html>`_ è"
#~ " un dispositivo a caratteri (char "
#~ "device) virtuale in grado di generare"
#~ " numeri casuali. Nello specifico, "
#~ "l'operazione di lettura dal relativo "
#~ "file produce byte casuali. Scrivere un"
#~ " programma C che genera un file "
#~ "con contenuto interamente randomico. Il "
#~ "programma:"
#~ msgstr ""

#~ msgid "Soluzione: *FCFS*:"
#~ msgstr ""

#~ msgid "2.05"
#~ msgstr ""

#~ msgid "Release Time"
#~ msgstr ""

#~ msgid "Release"
#~ msgstr ""

#~ msgid "Time"
#~ msgstr ""

#~ msgid "CPU"
#~ msgstr ""

#~ msgid "1.00                                   + 1.5               + 1.83"
#~ msgstr ""

#~ msgid "|"
#~ msgstr ""

#~ msgid "1.00                                  + 1.5               + 1.83"
#~ msgstr ""

#~ msgid "Assumption 2: Lo scheduler è attivato all'arrivo del primo processo"
#~ msgstr ""

#~ msgid ""
#~ "Latenza massima: accesso al un blocco"
#~ " più lontano da quello indicizzato, "
#~ "indice NON presente in RAM."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere il concetto di interrupt e"
#~ " mostrare il suo utilizzo nei sistemi"
#~ " operativi."
#~ msgstr ""

#~ msgid "Descrivere le principali strutture dati di un sistema operativo."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere i principali benefici e le"
#~ " criticità introdotte della multiprogrammazione."
#~ msgstr ""

#~ msgid ""
#~ "Cosa sono le system call e quali"
#~ " relazioni hanno con le librerie di"
#~ " sistema?"
#~ msgstr ""

#~ msgid ""
#~ "Riportare esempi di supporti hardware "
#~ "necessari al sistema operativo per "
#~ "garantire la protezione delle risorse."
#~ msgstr ""

#~ msgid "Quali sono gli obiettivi principali di un sistema operativo?"
#~ msgstr ""

#~ msgid ""
#~ "Perché la distinzione tra modo kernel"
#~ " e modo user è una forma di "
#~ "protezione?"
#~ msgstr ""

#~ msgid ""
#~ "Descrivere 3 servizi di sistema "
#~ "operativo e spiegare perché sono "
#~ "convenienti per gli utenti. Inoltre, "
#~ "perché è sconveniente che siano forniti"
#~ " da programmi user?"
#~ msgstr ""

#~ msgid ""
#~ "Descrivere le principali caratteristiche di"
#~ " un sistema batch e di un "
#~ "sistema batch multiprogrammato, discutendo "
#~ "anche in modo comparativo i vantaggi "
#~ "o svantaggi dell'uno verso l'altro."
#~ msgstr ""

#~ msgid "Descrivi il concetto di mode switch e di process switch."
#~ msgstr ""

#~ msgid ""
#~ "Descrivi il concetto di processo. Quali"
#~ " sono i possibili stati di un "
#~ "processo?"
#~ msgstr ""

#~ msgid "Spiegare la differenza tra il processo e thread."
#~ msgstr ""

#~ msgid ""
#~ "Quando un processo viene creato tramite"
#~ " *fork*, cosa è condiviso tra "
#~ "processo parent e child?"
#~ msgstr ""

#~ msgid "Quale è la differenza tra User-Level Thread e Kernel-Level Thread?"
#~ msgstr ""

#~ msgid ""
#~ "Quando un thread viene creato tramite"
#~ " *pthread_create*, cosa è condiviso tra "
#~ "thread parent e child?"
#~ msgstr ""

#~ msgid "Cpu-scheduler: quali sono i criteri di valutazione di un CPU scheduler?"
#~ msgstr ""

#~ msgid ""
#~ "Quali sfide introducono le architetture "
#~ "multicore nell'ambito del CPU scheduling?"
#~ msgstr ""

#~ msgid "Quale è la differenza tra uno scheduler preemtive e uno non-preemptive?"
#~ msgstr ""

#~ msgid ""
#~ "Descrivere la politica Shortest Job "
#~ "First e discuterne vantaggi e svantaggi."
#~ msgstr ""

#~ msgid "Descrivere la politica Round Robin e discuterne vantaggi e svantaggi."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere la politica di Fair-Share "
#~ "scheduling e quali problematiche risolve."
#~ msgstr ""

#~ msgid "Descrivere lo scheduler Linux."
#~ msgstr ""

#~ msgid "Descrivere lo scheduler Multilevel Feedback Queue."
#~ msgstr ""

#~ msgid ""
#~ "Quale è il vantaggio di avere "
#~ "time-slice differenti in uno scheduler "
#~ "basato su code multilivello con "
#~ "feedback?"
#~ msgstr ""

#~ msgid ""
#~ "Come è possibile parametrizzare uno "
#~ "scheduler basato su priorità per emulare"
#~ " gli scheduler Shortest Job First, "
#~ "First Come First Serve?"
#~ msgstr ""

#~ msgid ""
#~ "Descrivere lo scheduler di CPU round-"
#~ "robin virtuale, discutendone vantaggi e "
#~ "svantaggi rispetto allo scheduler round-"
#~ "robin."
#~ msgstr ""

#~ msgid ""
#~ "Si descrivano gli scheduler di CPU "
#~ "Shortest-Process-Next (SPN) e la "
#~ "sua variante Shortest–Remaining-Time-Next "
#~ "(SRTN), evidenziandone i vantaggi e gli"
#~ " svantaggi."
#~ msgstr ""

#~ msgid "Cos'è un'istruzione Read-Modify-Write?"
#~ msgstr ""

#~ msgid ""
#~ "Descrivere cosa è un lock e "
#~ "relative proprietà di correttezza e "
#~ "progresso."
#~ msgstr ""

#~ msgid "Descrivere il Bakery algorithm."
#~ msgstr ""

#~ msgid ""
#~ "Gli spinlock sono appropriati in un "
#~ "sistema single-core? Motiva la tua "
#~ "risposta."
#~ msgstr ""

#~ msgid ""
#~ "Descrivi la paginazione e la "
#~ "segmentazione mostrando vantaggi e svantaggi"
#~ " di ciascuna."
#~ msgstr ""

#~ msgid ""
#~ "Mostra lo schema di paginazione a "
#~ "due livelli e il processo di "
#~ "traduzione di un indirizzo virtuale in"
#~ " fisico. Quali sono i vantaggi e "
#~ "gli svantaggi nell'uso di tale schema?"
#~ msgstr ""

#~ msgid "Cosa è e a cosa serve il translation lookside buffer?"
#~ msgstr ""

#~ msgid ""
#~ "Mostrare uno schema di segmentazione "
#~ "paginata con TLB e descriverne il "
#~ "funzionamento per la traduzione da "
#~ "indirizzo logico a fisico."
#~ msgstr ""

#~ msgid "Che cosa è un buddy system?"
#~ msgstr ""

#~ msgid "Descrivi l'anomalia di Belady."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere l'algoritmo dell'orologio nell'ambito "
#~ "delle politiche di replacement delle "
#~ "pagine."
#~ msgstr ""

#~ msgid "Descrivere gli aspetti principali di gestione della memoria virtuale."
#~ msgstr ""

#~ msgid ""
#~ "Descrizione la gestione di un page "
#~ "fault nel caso di memoria virtuale "
#~ "basata su paginazione."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere le caratteristiche delle politiche"
#~ " di gestione del resident set di "
#~ "processo."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere il fenomeno del thrashing nel"
#~ " contesto della memoria virtuale."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere la tecnica di gestione delle"
#~ " memoria basata su partizioni dinamiche,"
#~ " indicando anche di quali supporti "
#~ "per il binding degli indirizzi questa"
#~ " necessita."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere l'algoritmo di selezione Least-"
#~ "Recently-Used (LRU) per sistemi di "
#~ "memoria virtuale basati su paginazione."
#~ msgstr ""

#~ msgid ""
#~ "Si descriva la tecnica della "
#~ "paginazione, indicando quali siano le "
#~ "strutture dati fondamentali che un "
#~ "sistema operativo deve gestire per "
#~ "metterla in atto."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere l'algoritmo ottimo per la "
#~ "sostituzione delle pagine in ambiente di"
#~ " memoria virtuale. Si indichi infine "
#~ "se tale algoritmo soffra o meno "
#~ "dell'anomalia di Belady, motivando la "
#~ "risposta."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere la struttura e l'utilizzo "
#~ "della tabella delle pagine e la "
#~ "relazione tra questa ed i componenti "
#~ "hardware presenti su una architettura di"
#~ " processore convenzionale."
#~ msgstr ""

#~ msgid ""
#~ "Quali sono le difficoltà che introduce"
#~ " il Direct Memory Access rispetto "
#~ "alla gestione dei processi?"
#~ msgstr ""

#~ msgid "Descrivere la tecnica di I/O buffering e la sua utilità."
#~ msgstr ""

#~ msgid "Spiegare le criticità nel progettare politiche di I/O scheduling."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere le politiche First-Come-"
#~ "First-Served e Shortest-Seek-Time-"
#~ "First per disk scheduling e illustrarne"
#~ " vantaggi e svantaggi."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere la politica SCAN per disk "
#~ "scheduling e spiegarne vantaggi e "
#~ "limiti. Per le limitazioni descritte, "
#~ "riportare possibili soluzioni."
#~ msgstr ""

#~ msgid "Cosa è un file e quali sono i suoi principali attributi?"
#~ msgstr ""

#~ msgid "Cosa è un file system e quali sono i suoi compiti principali?"
#~ msgstr ""

#~ msgid ""
#~ "Descrivere i metodi di accesso a "
#~ "file sequenziale, diretto ed indicizzato."
#~ msgstr ""

#~ msgid "Descrivere le caratteristiche salienti del file system UNIX."
#~ msgstr ""

#~ msgid "Cosa è un in-memory file system e riportarne alcuni esempi."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere i classici metodi di "
#~ "allocazione dei file sui dispositivi, "
#~ "discutendone vantaggi e svantaggi in "
#~ "modo comparato."
#~ msgstr ""

#~ msgid ""
#~ "Descrivere cosa sono gli \"hard link\""
#~ " ed i \"soft link\" in un "
#~ "file-system."
#~ msgstr ""

#~ msgid "Si descriva il metodo di allocazione dei file a catena."
#~ msgstr ""

#~ msgid "1 - Introduzione"
#~ msgstr ""

#~ msgid "2- Processi e thread"
#~ msgstr ""

#~ msgid "3 - Scheduling"
#~ msgstr ""

#~ msgid "4 - Sincronizzazione"
#~ msgstr ""

#~ msgid "5 - Gestione della memoria"
#~ msgstr ""

#~ msgid "6 - I/O Management"
#~ msgstr ""

#~ msgid "7 - File management"
#~ msgstr ""

#~ msgid "Si consideri un programma di cui:"
#~ msgstr ""

#~ msgid "il 60% del tempo di esecuzione è parallelizzabile;"
#~ msgstr ""

#~ msgid ""
#~ "l'80% del tempo non parallelizzabile può"
#~ " essere ottimizzato tramite l'adozione di"
#~ " un algoritmo 16 volte più veloce."
#~ msgstr ""

#~ msgid "Calcolare lo speedup ottenibile tramite:"
#~ msgstr ""

#~ msgid "la sola ottimizzazione a) con 2 e 4 core;"
#~ msgstr ""

#~ msgid "tramite la sola ottimizzazione b);"
#~ msgstr ""

#~ msgid "l'applicazione congiunta di a) e b) con 2 e 4 core."
#~ msgstr ""

#~ msgid ""
#~ "Infine, riportare lo speedup massimo "
#~ "raggiungibile tramite ottimizzazione a) e "
#~ "b)."
#~ msgstr ""

#~ msgid "**Mostra/Nascondi Soluzione**"
#~ msgstr ""

#~ msgid "*FCFS*:"
#~ msgstr ""

#~ msgid "process"
#~ msgstr ""

#~ msgid "P1"
#~ msgstr ""

#~ msgid "P2"
#~ msgstr ""

#~ msgid "P3"
#~ msgstr ""

#~ msgid "P4"
#~ msgstr ""

#~ msgid "CPU Release Time"
#~ msgstr ""

#~ msgid "1.00"
#~ msgstr ""

#~ msgid "1.5"
#~ msgstr ""

#~ msgid "1.83"
#~ msgstr ""

#~ msgid "2.08"
#~ msgstr ""

#~ msgid "Processo"
#~ msgstr ""

#~ msgid "Primo Accesso"
#~ msgstr ""

#~ msgid "Completamento"
#~ msgstr ""

#~ msgid "0"
#~ msgstr ""

#~ msgid "1"
#~ msgstr ""

#~ msgid "*SPN*:"
#~ msgstr ""

#~ msgid ""
#~ "Assunzione 1: Lo scheduler viene "
#~ "attivato dopo l'arrivo di tutti i "
#~ "processi"
#~ msgstr ""

#~ msgid "0.25"
#~ msgstr ""

#~ msgid "0.58"
#~ msgstr ""

#~ msgid "1.08"
#~ msgstr ""

#~ msgid "Assunzione 2: Lo scheduler è attivato all'arrivo del primo processo"
#~ msgstr ""

#~ msgid "1.25"
#~ msgstr ""

#~ msgid "1.58"
#~ msgstr ""

#~ msgid "*RR*:"
#~ msgstr ""

#~ msgid "0.125"
#~ msgstr ""

#~ msgid "0.250"
#~ msgstr ""

#~ msgid "0.375"
#~ msgstr ""

#~ msgid "0.500"
#~ msgstr ""

#~ msgid "0.625"
#~ msgstr ""

#~ msgid "0.750"
#~ msgstr ""

#~ msgid "0.875"
#~ msgstr ""

#~ msgid "1.000"
#~ msgstr ""

#~ msgid "1.125"
#~ msgstr ""

#~ msgid "1.250"
#~ msgstr ""

#~ msgid "1.333"
#~ msgstr ""

#~ msgid "1.458"
#~ msgstr ""

#~ msgid "1.583"
#~ msgstr ""

#~ msgid "2.083"
#~ msgstr ""

#~ msgid "0.000"
#~ msgstr ""

#~ msgid "1.33"
#~ msgstr ""

#~ msgid ""
#~ "Si consideri uno scenario in cui "
#~ "uno scheduler Multilevel-feedback queue "
#~ "abbia 4 livelli di priorità, ed in"
#~ " cui il quanto di tempo assegnato "
#~ "ai processi al livello i sia di"
#~ " 1/2^i millisecondi. Si supponga che "
#~ "all'istante T0 nascano 2 processi A "
#~ "e B, entrambi CPU-bound. Il "
#~ "processo B richiede 10 millisecondi di"
#~ " tempo di CPU per completare la "
#~ "sua esecuzione. Si identifichi la durata"
#~ " massima (in termini di tempo di "
#~ "CPU) del processo A affinché il "
#~ "processo B possa completare la sua "
#~ "esecuzione entro il tempo T0+17 nei "
#~ "due casi in cui il primo processo"
#~ " ad essere schedulato in CPU sia "
#~ "A oppure B. Si supponga che il "
#~ "tempo di CPU per i context switch"
#~ " e per l'esecuzione dello scheduler "
#~ "sia nullo."
#~ msgstr ""

#~ msgid ""
#~ "Si consideri uno scenario in cui "
#~ "al tempo T0 nasca un processo P0"
#~ " puramente CPU-bound di durata (tempo"
#~ " di CPU) pari a 10 secondi ed"
#~ " al tempo T0 + 3 secondi P0 "
#~ "origini un altro processo P1 puramente"
#~ " CPU-bound di durata (tempo di "
#~ "CPU) pari a 6 secondi. Supponendo "
#~ "che le durate dei processi siano "
#~ "note al tempo della loro generazione,"
#~ " e che il tempo di CPU per "
#~ "eseguire uno scheduler sia trascurabile. "
#~ "si calcoli il tempo massimo di "
#~ "completamento del processo P1 nel caso"
#~ " in cui il sistema abbia come "
#~ "scheduler Shortest Process Next oppure "
#~ "Shortest-Remaining-Time Next."
#~ msgstr ""

#~ msgid ""
#~ "Si consideri il caso di memoria "
#~ "virtuale basata su paginazione a più "
#~ "livelli, indirizzi logici e fisici a "
#~ "N bit, pagine di 4MB e tabelle "
#~ "pari alla dimensione di una pagina. "
#~ "Rispondere alle seguenti domande considerando"
#~ " N pari a 40 bit e 48 "
#~ "bit."
#~ msgstr ""

#~ msgid "Quanti bit servono per spiazzarsi all'interno di una pagina?"
#~ msgstr ""

#~ msgid ""
#~ "Quanti bit servono per identificare una"
#~ " pagina nel caso di N uguale a"
#~ " 40 bit e 48 bit?"
#~ msgstr ""

#~ msgid ""
#~ "Supponendo di utilizzare un numero di"
#~ " bit per entry in una tabella "
#~ "pari alla minima potenza di 2 "
#~ "necessaria a memorizzare un frame "
#~ "number, quante entry possono essere "
#~ "memorizzate in una tabella?"
#~ msgstr ""

#~ msgid "Quanti livelli sono necessari?"
#~ msgstr ""

#~ msgid ""
#~ "Qual è la struttura dell'indirizzo e "
#~ "l'utilizzo dei bit nel suddetto schema"
#~ " di paginazione?"
#~ msgstr ""

#~ msgid ""
#~ "Qual è il numero massimo di frame"
#~ " di memoria impegnati da un processo"
#~ " nel caso in cui il numero "
#~ "delle tabelle a qualsiasi livello "
#~ "correntemente usate per quel processo in"
#~ " suddetto schema di paginazione sia "
#~ "pari a 10?"
#~ msgstr ""

#~ msgid ""
#~ "Data una memoria principale di 4 "
#~ "frame, si determini quanti e quali "
#~ "page fault vengono generati dagli "
#~ "algoritmi FIFO, LRU e Ottimo per "
#~ "la sostituzione delle pagine in sistemi"
#~ " con memoria virtuale data la "
#~ "seguente traccia: 0 9 0 3 5 "
#~ "7 9 0 9 6 7 8 9 7 "
#~ "6 4"
#~ msgstr ""

#~ msgid "*FIFO*: #PageFault = 11"
#~ msgstr ""

#~ msgid "**0**"
#~ msgstr ""

#~ msgid "**9**"
#~ msgstr ""

#~ msgid "**3**"
#~ msgstr ""

#~ msgid "**5**"
#~ msgstr ""

#~ msgid "**7**"
#~ msgstr ""

#~ msgid "9"
#~ msgstr ""

#~ msgid "**6**"
#~ msgstr ""

#~ msgid "7"
#~ msgstr ""

#~ msgid "**8**"
#~ msgstr ""

#~ msgid "6"
#~ msgstr ""

#~ msgid "**4**"
#~ msgstr ""

#~ msgid "3"
#~ msgstr ""

#~ msgid "5"
#~ msgstr ""

#~ msgid "8"
#~ msgstr ""

#~ msgid "4"
#~ msgstr ""

#~ msgid "E"
#~ msgstr ""

#~ msgid "*Least-Recently Used*: #PageFault = 10"
#~ msgstr ""

#~ msgid "*Optimal*: #PageFault = 8"
#~ msgstr ""

#~ msgid ""
#~ "Considerando uno schema di paginazione a"
#~ " 3 livelli in cui la tabella di"
#~ " primo livello sia costituita da 4"
#~ " K elementi, quella di secondo "
#~ "livello da 2 K elementi e quella"
#~ " di terzo livello da 1 K "
#~ "elementi, si determini il numero massimo"
#~ " di pagine gestibili all'interno dello "
#~ "spazio di indirizzamento di un processo."
#~ msgstr ""

#~ msgid ""
#~ "Si consideri una sequenza di generazione"
#~ " di 4 processi, P4, P1, P2 e"
#~ " P3. P1 e P2 hanno taglia 1MB,"
#~ " P3 ha taglia 2 MB e P4 "
#~ "ha taglia 4 MB. Il sistema con "
#~ "multiprogrammazione è caratterizzato da:"
#~ msgstr ""

#~ msgid ""
#~ "una memoria di lavoro di 7 MB "
#~ "di cui 1 MB sia riservato per "
#~ "il sistema operativo"
#~ msgstr ""

#~ msgid ""
#~ "un meccanismo di allocazione dei "
#~ "processi basato su partizioni dinamiche."
#~ msgstr ""

#~ msgid ""
#~ "Assumendo che P4 non termini prima "
#~ "di P3, si determini quale deve "
#~ "essere la relazione tra il tempo "
#~ "di completamento di P1 e P2 ed "
#~ "il tempo di nascita di P3 "
#~ "affinché, e sotto quali condizioni, "
#~ "ognuno dei 4 processi possa essere "
#~ "correttamente allocato in memoria all'atto "
#~ "della sua creazione."
#~ msgstr ""

#~ msgid "**P2**"
#~ msgstr ""

#~ msgid "**P3**"
#~ msgstr ""

#~ msgid "**P1**"
#~ msgstr ""

#~ msgid "**P4**"
#~ msgstr ""

#~ msgid "2"
#~ msgstr ""

#~ msgid "**MONITOR**"
#~ msgstr ""

#~ msgid ""
#~ "Siano S_i e T_i rispettivamente "
#~ "l'istante di inizio e terminazione del"
#~ " processo i"
#~ msgstr ""

#~ msgid "Vincoli:"
#~ msgstr ""

#~ msgid "S_4 < S_1 < S_2 < S_3"
#~ msgstr ""

#~ msgid "T_4 > S_3"
#~ msgstr ""

#~ msgid "Soluzione:"
#~ msgstr ""

#~ msgid ""
#~ "Si consideri inoltre uno scenario in "
#~ "cui arrivino al sistema operativo "
#~ "richieste per accedere alle seguenti "
#~ "tracce di un disco: 33 – 46 "
#~ "– 98 – 12 – 43 – 56 –"
#~ " 78 - 77 – 25. Si determini "
#~ "la sequenza effettiva di schedulazione "
#~ "delle operazioni verso il disco "
#~ "considerando che:"
#~ msgstr ""

#~ msgid ""
#~ "al più 4 richieste per volta "
#~ "possono essere immagazzinate nella coda "
#~ "di scheduling;"
#~ msgstr ""

#~ msgid "la testina sia inizialmente posta sulla traccia 100 del disco;"
#~ msgstr ""

#~ msgid "l'algoritmo utilizzato è SCAN."
#~ msgstr ""

#~ msgid ""
#~ "Si consideri un file system con "
#~ "allocazione a catena ed accesso "
#~ "indicizzato. Dato un file:"
#~ msgstr ""

#~ msgid "contente 1M record;"
#~ msgstr ""

#~ msgid ""
#~ "il relativo indice ha taglia pari "
#~ "a 512 record e contiene 128 chiavi"
#~ " uniformemente distribuite nel file;"
#~ msgstr ""

#~ msgid ""
#~ "memorizzato su un dispositivo di massa,"
#~ " la cui taglia di un blocco è"
#~ " pari a 4096 record."
#~ msgstr ""

#~ msgid "Calcolare la latenza massima e minima considerando che:"
#~ msgstr ""

#~ msgid "il tempo medio di accesso ad un blocco è 10ms;"
#~ msgstr ""

#~ msgid "l'accesso ad una chiave dell'indice in ram è pari a 1ms."
#~ msgstr ""

#~ msgid "Assunzioni:"
#~ msgstr ""

#~ msgid "L'indice è memorizzato su disco"
#~ msgstr ""

#~ msgid "L'indice deve essere prima caricato in ram per poter essere utilizzato"
#~ msgstr ""

#~ msgid "RecordID e RiferimentoBlocco hanno pari taglia"
#~ msgstr ""

#~ msgid "Svolgimento:"
#~ msgstr ""

#~ msgid ""
#~ "Taglia di una chiave nell'indice = "
#~ "TagliaIndice/NumeroChiavi = 512R/128 = 4R"
#~ msgstr ""

#~ msgid "Taglia di un riferimento = 2R"
#~ msgstr ""

#~ msgid ""
#~ "Record utilizzabili all'interno di un "
#~ "blocco per memorizzare dati di file "
#~ "= Taglia di un blocco - Taglia "
#~ "di un riferimento = 4096-2 = 4094"
#~ msgstr ""

#~ msgid ""
#~ "Numero di blocchi per memorizzare il "
#~ "file = Numero di record nel file"
#~ " / record utilizzabili = ceil(10^6/4094)"
#~ " = 245"
#~ msgstr ""

#~ msgid ""
#~ "Distanza media tra due blocchi "
#~ "indicizzati = ceil(Numero di blocchi /"
#~ " numero di chiavi) = 2"
#~ msgstr ""

#~ msgid ""
#~ "Latenza minima: accesso ad un blocco "
#~ "indicizzato, indice già presente in RAM."
#~ msgstr ""

#~ msgid ""
#~ "Risultato = Tempo di accesso a "
#~ "indice + Accesso al blocco indicizzato"
#~ " = 1ms +10ms = 11ms"
#~ msgstr ""

#~ msgid ""
#~ "Latenza massima: accesso al blocco più"
#~ " lontano da quello indicizzato, indice "
#~ "NON presente in RAM."
#~ msgstr ""

#~ msgid ""
#~ "Risultato = Tempo di caricamento indice"
#~ " +  Tempo di accesso a indice +"
#~ " (Numero di blocchi per indice)*(Tempo "
#~ "di accesso al blocco indicizzato) = "
#~ "+10ms + 1ms +2*10ms = 31ms"
#~ msgstr ""

#~ msgid ""
#~ "Si consideri un file system con "
#~ "allocazione indicizzata ospitato su un "
#~ "dispositivo i cui blocchi hanno taglia"
#~ " pari a 1024 record e un "
#~ "riferimento a blocco occupa 8 record."
#~ " Il record di sistema ha:"
#~ msgstr ""

#~ msgid "128 entry per accesso diretto;"
#~ msgstr ""

#~ msgid "4 entry per accesso indiretto;"
#~ msgstr ""

#~ msgid "4 entry per accesso doppiamente indiretto."
#~ msgstr ""

#~ msgid "Qual è la taglia massima di un file in record?"
#~ msgstr ""

#~ msgid ""
#~ "Si consideri inoltre senario dove un "
#~ "processo P apra un file F "
#~ "(attualmente non in uso da parte "
#~ "di alcun processo) e poi esegua 2"
#~ " fork(). Indicare il numero delle "
#~ "sessioni di I/O verso  il file F"
#~ " a valle dell'esecuzione delle 2 "
#~ "fork() da parte di P."
#~ msgstr ""

#~ msgid ""
#~ "Si consideri un dispositivo di memoria"
#~ " di massa con blocchi di taglia "
#~ "pari a 4 KB, indici di blocchi "
#~ "di taglia pari a 4 byte, ed "
#~ "un record di sistema contenente in "
#~ "totale 12 indici di cui N diretti"
#~ " ed M indiretti. Si determini il "
#~ "valore di N ed M, qualora esista,"
#~ " che possa permettere di allocare "
#~ "file di taglia almeno pari a 4 "
#~ "GB."
#~ msgstr ""

#~ msgid ""
#~ "Si supponga di avere un file "
#~ "system che supporta il metodo di "
#~ "allocazione a catena. Si supponga "
#~ "inoltre che il dispositivo di memoria"
#~ " di massa ove il file system è"
#~ " ospitato abbia blocchi di taglia "
#~ "pari a 4 K record, e che un"
#~ " indice (puntatore) di blocco di "
#~ "dispositivo sia espresso con 16 record."
#~ " Si supponga inoltre di avere un "
#~ "file F di taglia pari a 16 M"
#~ " record. Si calcoli il numero di "
#~ "blocchi necessari ad allocare il file"
#~ " sul dispositivo di memoria di massa"
#~ " secondo lo schema a catena."
#~ msgstr ""

#~ msgid "8- Programmazione"
#~ msgstr ""

#~ msgid ""
#~ "Nei sistemi operativi UNIX, `/dev/urandom "
#~ "<https://man7.org/linux/man-pages/man4/random.4.html>`_ è"
#~ " un dispositivo a caratteri (char "
#~ "device) virtuale in grado di generare"
#~ " numeri casuali. Nello specifico, "
#~ "l'operazione di lettura dal relativo "
#~ "file produce byte casuali. Scrivere un"
#~ " programma C che genera un file "
#~ "con contenuto interamente randomico. Il "
#~ "programma:"
#~ msgstr ""

#~ msgid ""
#~ "prende come parametri da linea di "
#~ "comando: un numero *N* e una "
#~ "stringa *S* da usare come nome del"
#~ " file da creare;"
#~ msgstr ""

#~ msgid "crea un file *S* contenente *N* byte randomici;"
#~ msgstr ""

#~ msgid ""
#~ "utilizza il dispositivo /dev/random come "
#~ "sorgente di numeri pseudo-casuali."
#~ msgstr ""

#~ msgid ""
#~ "Dato un file binario contenente un "
#~ "sequenza di 2^15 interi di tipo "
#~ "*short*, scrivere un programma che crea"
#~ " N processi o threads, i quali "
#~ "leggono il contenuto del file ed "
#~ "individuano il valore minimo e massimo"
#~ " contenuto nel file. Nel fornire una"
#~ " soluzione rispettare i seguenti vincoli:"
#~ msgstr ""

#~ msgid "ciascun intero non può essere letto da più di un thread/processo;"
#~ msgstr ""

#~ msgid ""
#~ "ciascun thread/processo può leggere il "
#~ "medesimo intero al più una volta;"
#~ msgstr ""

#~ msgid ""
#~ "ciascun thread/processo può allocare memoria"
#~ " nell'heap per al più 512 byte;"
#~ msgstr ""

#~ msgid ""
#~ "N è un parametro definito a tempo"
#~ " di compilazione o tramite linea di"
#~ " comando;"
#~ msgstr ""

#~ msgid "N è minore o uguale a 8;"
#~ msgstr ""

#~ msgid ""
#~ "è ammesso allocare di variabili globali"
#~ " (data) e locali (stack) per "
#~ "memorizzare tipi primitivi (puntatori, int,"
#~ " short, char, long, etc.) per al "
#~ "più 128 byte."
#~ msgstr ""

#~ msgid ""
#~ "Per generare il file è possibile "
#~ "utilizzare la soluzione dell'esercizio 1."
#~ msgstr ""

#~ msgid ""
#~ "Scrivere un programma C *invert* che "
#~ "dato un file *A* ne inverte il "
#~ "contenuto e lo memorizza in nuovo "
#~ "file *B*. Il programma deve:"
#~ msgstr ""

#~ msgid "riportare il contenuto di *A* in memoria;"
#~ msgstr ""

#~ msgid ""
#~ "invertire la posizione di ciascun byte"
#~ " utilizzando un numero *N* di "
#~ "thread/processi concorrenti;"
#~ msgstr ""

#~ msgid "scrivere il risultato in un nuovo file *B*."
#~ msgstr ""

#~ msgid ""
#~ "*A*, *B* e *N* sono parametri che"
#~ " il programma deve acquisire da linea"
#~ " di comando."
#~ msgstr ""

#~ msgid ""
#~ "**SOLUZIONE**: `Github "
#~ "<https://github.com/SistemiOperativi/c_examples/tree/main/ex_8_3>`__"
#~ msgstr ""

#~ msgid ""
#~ "Si scriva il codice di una "
#~ "funzione C con la seguente interfaccia"
#~ " :code:`void tunnel(int descriptors[], int "
#~ "count)` tale che, se eseguita, porti "
#~ "l'applicazione a gestire, per ogni "
#~ "file-descriptor dell'array *descriptors* "
#~ "l'inoltro del flusso  dei dati in "
#~ "ingresso verso il canale di standard-"
#~ "output dell'applicazione. Il parametro *count*"
#~ " indica di quanti elementi è "
#~ "costituito l'array *descriptors*. L'inoltro "
#~ "dovrà essere attuato in modo concorrente"
#~ " per i diversi canali."
#~ msgstr ""

#~ msgid ""
#~ "Si scriva una funzione C con la"
#~ " seguente interfaccia :code:`void file_check(char"
#~ " *file_name, int num_threads)`. Tale "
#~ "funzione dovrà lanciare num_thread nuovi "
#~ "threads, in modo che ciascuno di "
#~ "essi legga stringhe dallo standard "
#~ "input, e per ogni stringa letta "
#~ "verifichi l'occorrenza di tale stringa "
#~ "all'interno *di ciascuna riga* del file"
#~ " il cui path è identificato tramite"
#~ " il parametro file_name, e stampi la"
#~ " stringa su standard output in caso"
#~ " affermativo."
#~ msgstr ""

#~ msgid ""
#~ "Scrivere un programma C in cui "
#~ "dato un file *A*, una stringa *B*"
#~ " e un intero *N*, vengano creati "
#~ "*N* thread/processi che cerchino se "
#~ "all'interno del file *A* esiste una "
#~ "linea uguale a *B*."
#~ msgstr ""

#~ msgid "..#. Si consideri un programma di cui:"
#~ msgstr ""

#~ msgid ""
#~ "..#. Si consideri un file system "
#~ "con allocazione a catena ed accesso "
#~ "indicizzato. Dato un file:"
#~ msgstr ""

#~ msgid "..----------------"
#~ msgstr ""

#~ msgid ""
#~ "..2. Si consideri un file system "
#~ "con allocazione indicizzata ospitato su "
#~ "un dispositivo i cui blocchi hanno "
#~ "taglia pari a 1024 record e un "
#~ "riferimento a blocco occupa 8 record."
#~ " Il record di sistema ha:"
#~ msgstr ""

#~ msgid ""
#~ "..3. Si consideri inoltre senario dove"
#~ " un processo P apra un file F"
#~ " (attualmente non in uso da parte "
#~ "di alcun processo) e poi esegua 2"
#~ " fork(). Indicare il numero delle "
#~ "sessioni di I/O verso  il file F"
#~ " a valle dell'esecuzione delle 2 "
#~ "fork() da parte di P. ..#. Si "
#~ "consideri un dispositivo di memoria di"
#~ " massa con blocchi di taglia pari "
#~ "a 4 KB, indici di blocchi di "
#~ "taglia pari a 4 byte, ed un "
#~ "record di sistema contenente in totale"
#~ " 12 indici di cui N diretti ed"
#~ " M indiretti. Si determini il valore"
#~ " di N ed M, qualora esista, che"
#~ " possa permettere di allocare file di"
#~ " taglia almeno pari a 4 GB. "
#~ "..#. Si supponga di avere un file"
#~ " system che supporta il metodo di "
#~ "allocazione a catena. Si supponga "
#~ "inoltre che il dispositivo di memoria"
#~ " di massa ove il file system è"
#~ " ospitato abbia blocchi di taglia "
#~ "pari a 4 K record, e che un"
#~ " indice (puntatore) di blocco di "
#~ "dispositivo sia espresso con 16 record."
#~ " Si supponga inoltre di avere un "
#~ "file F di taglia pari a 16 M"
#~ " record. Si calcoli il numero di "
#~ "blocchi necessari ad allocare il file"
#~ " sul dispositivo di memoria di massa"
#~ " secondo lo schema a catena."
#~ msgstr ""

#~ msgid ""
#~ "..#. Si consideri il caso di "
#~ "memoria virtuale basata su paginazione a"
#~ " più livelli, indirizzi logici e "
#~ "fisici a N bit, pagine di 4MB "
#~ "e tabelle pari alla dimensione di "
#~ "una pagina."
#~ msgstr ""

#~ msgid "Rispondere alle seguenti domande considerando N pari a 40 bit e 48 bit."
#~ msgstr ""

#~ msgid ""
#~ "..2. Data una memoria principale di "
#~ "4 frame, si determini quanti e "
#~ "quali page fault vengono generati dagli"
#~ " algoritmi FIFO, LRU e Ottimo per "
#~ "la sostituzione delle pagine in sistemi"
#~ " con memoria virtuale data la "
#~ "seguente traccia: 0 9 0 3 5 "
#~ "7 9 0 9 6 7 8 9 7 "
#~ "6 4"
#~ msgstr ""

#~ msgid "..-----------------"
#~ msgstr ""

#~ msgid ""
#~ "..3. Considerando uno schema di "
#~ "paginazione a 3 livelli in cui la"
#~ " tabella di primo livello sia "
#~ "costituita da 4 K elementi, quella "
#~ "di secondo livello da 2 K elementi"
#~ " e quella di terzo livello da 1"
#~ " K elementi, si determini il numero"
#~ " massimo di pagine gestibili all'interno"
#~ " dello spazio di indirizzamento di un"
#~ " processo. ..#. Si consideri una "
#~ "sequenza di generazione di 4 processi,"
#~ " P4, P1, P2 e P3."
#~ msgstr ""

#~ msgid ""
#~ "P1 e P2 hanno taglia 1MB, P3 "
#~ "ha taglia 2 MB e P4 ha "
#~ "taglia 4 MB. Il sistema con "
#~ "multiprogrammazione è caratterizzato da:"
#~ msgstr ""

#~ msgid ""
#~ "..#. Si consideri inoltre uno scenario"
#~ " in cui arrivino al sistema operativo"
#~ " richieste per accedere alle seguenti "
#~ "tracce di un disco: 33 – 46 "
#~ "– 98 – 12 – 43 – 56 –"
#~ " 78 - 77 – 25. Si determini "
#~ "la sequenza effettiva di schedulazione "
#~ "delle operazioni verso il disco "
#~ "considerando che:"
#~ msgstr ""

#~ msgid ""
#~ "..#. Si consideri uno scenario con "
#~ "4 processi {P1,..., P4} CPU-bound "
#~ "e generati in sequenza a partire "
#~ "da P1 a P4 con ritardi "
#~ "trascurabili."
#~ msgstr ""

#~ msgid ""
#~ "Il processo Pi richiede 1/i secondi "
#~ "di CPU per completare la propria "
#~ "esecuzione. Considerando che il ritardo "
#~ "di context-switch sia trascurabile e "
#~ "che RR abbia una time slice pari"
#~ " a 125ms, si calcoli per gli "
#~ "algoritmi FCFS, SPN e RR il tempo"
#~ " di primo accesso alla CPU e il"
#~ " tempo di completamento per ciascun "
#~ "processo."
#~ msgstr ""

#~ msgid "..--------------------------"
#~ msgstr ""

#~ msgid ""
#~ "..2. Si consideri uno scenario in "
#~ "cui uno scheduler Multilevel-feedback "
#~ "queue abbia 4 livelli di priorità, "
#~ "ed in cui il quanto di tempo "
#~ "assegnato ai processi al livello i "
#~ "sia di 1/2^i millisecondi. Si supponga"
#~ " che all'istante T0 nascano 2 "
#~ "processi A e B, entrambi CPU-"
#~ "bound. Il processo B richiede 10 "
#~ "millisecondi di tempo di CPU per "
#~ "completare la sua esecuzione. Si "
#~ "identifichi la durata massima (in "
#~ "termini di tempo di CPU) del "
#~ "processo A affinché il processo B "
#~ "possa completare la sua esecuzione entro"
#~ " il tempo T0+17 nei due casi in"
#~ " cui il primo processo ad essere "
#~ "schedulato in CPU sia A oppure B."
#~ " Si supponga che il tempo di "
#~ "CPU per i context switch e per "
#~ "l'esecuzione dello scheduler sia nullo. "
#~ "..#. Si consideri uno scenario in "
#~ "cui al tempo T0 nasca un processo"
#~ " P0 puramente CPU-bound di durata "
#~ "(tempo di CPU) pari a 10 secondi"
#~ " ed al tempo T0 + 3 secondi "
#~ "P0 origini un altro processo P1 "
#~ "puramente CPU-bound di durata (tempo "
#~ "di CPU) pari a 6 secondi. "
#~ "Supponendo che le durate dei processi"
#~ " siano note al tempo della loro "
#~ "generazione, e che il tempo di CPU"
#~ " per eseguire uno scheduler sia "
#~ "trascurabile. si calcoli il tempo "
#~ "massimo di completamento del processo P1"
#~ " nel caso in cui il sistema "
#~ "abbia come scheduler Shortest Process "
#~ "Next oppure Shortest-Remaining-Time "
#~ "Next."
#~ msgstr ""

#~ msgid "..comment:"
#~ msgstr ""

