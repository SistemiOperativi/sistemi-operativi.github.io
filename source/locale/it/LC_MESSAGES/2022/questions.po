# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022, Romolo Marotta
# This file is distributed under the same license as the Sistemi Operativi
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2022.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Sistemi Operativi \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-16 14:33+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.8.0\n"

#: ../source/2022/questions.rst:2
msgid "Esercizi di preparazione"
msgstr ""

#: ../source/2022/questions.rst:4
msgid ""
"In questa sezione vengono riportate alcuni esercizi/domande che possono "
"essere utilizzate come preparazione all'esame."
msgstr ""

#: ../source/2022/questions.rst:8
msgid "Domande"
msgstr ""

#: ../source/2022/q_exercises/intro.rst:2 ../source/2022/questions/intro.rst:2
msgid "1 - Introduzione"
msgstr ""

#: ../source/2022/questions/intro.rst:4
msgid ""
"Descrivere il concetto di interrupt e mostrare il suo utilizzo nei "
"sistemi operativi."
msgstr ""

#: ../source/2022/questions/intro.rst:5
msgid "Descrivere le principali strutture dati di un sistema operativo."
msgstr ""

#: ../source/2022/questions/intro.rst:6
msgid ""
"Descrivere i principali benefici e le criticità introdotte della "
"multiprogrammazione."
msgstr ""

#: ../source/2022/questions/intro.rst:7
msgid ""
"Cosa sono le system call e quali relazioni hanno con le librerie di "
"sistema?"
msgstr ""

#: ../source/2022/questions/intro.rst:8
msgid ""
"Riportare esempi di supporti hardware necessari al sistema operativo per "
"garantire la protezione delle risorse."
msgstr ""

#: ../source/2022/questions/intro.rst:9
msgid "Quali sono gli obiettivi principali di un sistema operativo?"
msgstr ""

#: ../source/2022/questions/intro.rst:10
msgid ""
"Perché la distinzione tra modo kernel e modo user è una forma di "
"protezione?"
msgstr ""

#: ../source/2022/questions/intro.rst:11
msgid ""
"Descrivere 3 servizi di sistema operativo e spiegare perché sono "
"convenienti per gli utenti. Inoltre, perché è sconveniente che siano "
"forniti da programmi user?"
msgstr ""

#: ../source/2022/questions/intro.rst:12
msgid ""
"Descrivere le principali caratteristiche di un sistema batch e di un "
"sistema batch multiprogrammato, discutendo anche in modo comparativo i "
"vantaggi o svantaggi dell'uno verso l'altro."
msgstr ""

#: ../source/2022/questions/processes.rst:2
msgid "2- Processi e thread"
msgstr ""

#: ../source/2022/questions/processes.rst:4
msgid "Descrivi il concetto di mode switch e di process switch."
msgstr ""

#: ../source/2022/questions/processes.rst:5
msgid ""
"Descrivi il concetto di processo. Quali sono i possibili stati di un "
"processo?"
msgstr ""

#: ../source/2022/questions/processes.rst:6
msgid ""
"Quando un processo viene creato tramite *fork*, cosa è condiviso tra "
"processo parent e child?"
msgstr ""

#: ../source/2022/questions/processes.rst:7
msgid "Spiegare la differenza tra il processo e thread."
msgstr ""

#: ../source/2022/questions/processes.rst:8
msgid "Quale è la differenza tra User-Level Thread e Kernel-Level Thread?"
msgstr ""

#: ../source/2022/questions/processes.rst:9
msgid ""
"Quando un thread viene creato tramite *pthread_create*, cosa è condiviso "
"tra thread parent e child?"
msgstr ""

#: ../source/2022/questions/sync.rst:2
msgid "3 - Sincronizzazione"
msgstr ""

#: ../source/2022/questions/sync.rst:4
msgid "Cos'è un'istruzione Read-Modify-Write?"
msgstr ""

#: ../source/2022/questions/sync.rst:5
msgid "Descrivere cosa è un lock e relative proprietà di correttezza e progresso."
msgstr ""

#: ../source/2022/questions/sync.rst:6
msgid "Descrivere il Bakery algorithm."
msgstr ""

#: ../source/2022/questions/sync.rst:7
msgid ""
"Gli spinlock sono appropriati in un sistema single-core? Motiva la tua "
"risposta."
msgstr ""

#: ../source/2022/questions/sched.rst:2
msgid "4 - Scheduling"
msgstr ""

#: ../source/2022/questions/sched.rst:4
msgid "Cpu-scheduler: quali sono i criteri di valutazione di un CPU scheduler?"
msgstr ""

#: ../source/2022/questions/sched.rst:5
msgid ""
"Quali sfide introducono le architetture multicore nell'ambito del CPU "
"scheduling?"
msgstr ""

#: ../source/2022/questions/sched.rst:6
msgid "Quale è la differenza tra uno scheduler preemtive e uno non-preemptive?"
msgstr ""

#: ../source/2022/questions/sched.rst:7
msgid ""
"Descrivere la politica Shortest Job First e discuterne vantaggi e "
"svantaggi."
msgstr ""

#: ../source/2022/questions/sched.rst:8
msgid "Descrivere la politica Round Robin e discuterne vantaggi e svantaggi."
msgstr ""

#: ../source/2022/questions/sched.rst:9
msgid ""
"Descrivere la politica di Fair-Share scheduling e quali problematiche "
"risolve."
msgstr ""

#: ../source/2022/questions/sched.rst:10
msgid "Descrivere lo scheduler Complete Fair Share in Linux."
msgstr ""

#: ../source/2022/questions/sched.rst:11
msgid "Descrivere lo scheduler Multilevel Feedback Queue."
msgstr ""

#: ../source/2022/questions/sched.rst:12
msgid ""
"Quale è il vantaggio di avere time-slice differenti in uno scheduler "
"basato su code multilivello con feedback?"
msgstr ""

#: ../source/2022/questions/sched.rst:13
msgid ""
"Come è possibile parametrizzare uno scheduler basato su priorità per "
"emulare gli scheduler Shortest Job First, First Come First Serve?"
msgstr ""

#: ../source/2022/questions/sched.rst:14
msgid ""
"Descrivere lo scheduler di CPU round-robin virtuale, discutendone "
"vantaggi e svantaggi rispetto allo scheduler round-robin."
msgstr ""

#: ../source/2022/questions/sched.rst:15
msgid ""
"Si descrivano gli scheduler di CPU Shortest-Process-Next (SPN) e la sua "
"variante Shortest–Remaining-Time-Next (SRTN), evidenziandone i vantaggi e"
" gli svantaggi."
msgstr ""

#: ../source/2022/questions.rst:22
msgid "Esercizi di teoria"
msgstr ""

#: ../source/2022/questions.rst:27
msgid ""
"Alcuni esercizi possono deliberatamente ammettere più di una soluzione in"
" funzione delle assunzioni fatte durante lo svolgimento. Di conseguenza, "
"le soluzioni proposte potrebbe non essere le uniche ammissibili."
msgstr ""

#: ../source/2022/q_exercises/intro.rst:5
msgid "Si consideri un programma di cui:"
msgstr ""

#: ../source/2022/q_exercises/intro.rst:7
#, python-format
msgid "il 60% del tempo di esecuzione è parallelizzabile;"
msgstr ""

#: ../source/2022/q_exercises/intro.rst:8
#, python-format
msgid ""
"l'80% del tempo non parallelizzabile può essere ottimizzato tramite "
"l'adozione di un algoritmo 16 volte più veloce."
msgstr ""

#: ../source/2022/q_exercises/intro.rst:10
msgid "Calcolare lo speedup ottenibile tramite:"
msgstr ""

#: ../source/2022/q_exercises/intro.rst:12
msgid "la sola ottimizzazione a) con 2 e 4 core;"
msgstr ""

#: ../source/2022/q_exercises/intro.rst:13
msgid "tramite la sola ottimizzazione b);"
msgstr ""

#: ../source/2022/q_exercises/intro.rst:14
msgid "l'applicazione congiunta di a) e b) con 2 e 4 core."
msgstr ""

#: ../source/2022/q_exercises/intro.rst:16
msgid ""
"Infine, riportare lo speedup massimo raggiungibile tramite ottimizzazione"
" a) e b)."
msgstr ""

#: ../source/2022/q_exercises/sched.rst:2
msgid "3 - Scheduling"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:5
msgid ""
"Si consideri uno scenario con 4 processi {P1,..., P4} CPU-bound e "
"generati in sequenza a partire da P1 a P4 con ritardi trascurabili."
msgstr ""

#: ../source/2022/q_exercises/sched.rst:6
msgid ""
"Il processo Pi richiede 1/i secondi di CPU per completare la propria "
"esecuzione. Considerando che il ritardo di context-switch sia "
"trascurabile e che RR abbia una time slice pari a 125ms, si calcoli per "
"gli algoritmi FCFS, SPN e RR il tempo di primo accesso alla CPU e il "
"tempo di completamento per ciascun processo."
msgstr ""

#: ../source/2022/q_exercises/sched.rst:13
msgid "**Mostra/Nascondi Soluzione**"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:17
msgid "*FCFS*:"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:20
#: ../source/2022/q_exercises/sched.rst:44
#: ../source/2022/q_exercises/sched.rst:67
#: ../source/2022/q_exercises/sched.rst:89
msgid "process"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:20
#: ../source/2022/q_exercises/sched.rst:30
#: ../source/2022/q_exercises/sched.rst:44
#: ../source/2022/q_exercises/sched.rst:54
#: ../source/2022/q_exercises/sched.rst:67
#: ../source/2022/q_exercises/sched.rst:77
#: ../source/2022/q_exercises/sched.rst:89
#: ../source/2022/q_exercises/sched.rst:101
msgid "P1"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:20
#: ../source/2022/q_exercises/sched.rst:32
#: ../source/2022/q_exercises/sched.rst:44
#: ../source/2022/q_exercises/sched.rst:56
#: ../source/2022/q_exercises/sched.rst:67
#: ../source/2022/q_exercises/sched.rst:79
#: ../source/2022/q_exercises/sched.rst:89
#: ../source/2022/q_exercises/sched.rst:103
msgid "P2"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:20
#: ../source/2022/q_exercises/sched.rst:34
#: ../source/2022/q_exercises/sched.rst:44
#: ../source/2022/q_exercises/sched.rst:58
#: ../source/2022/q_exercises/sched.rst:67
#: ../source/2022/q_exercises/sched.rst:81
#: ../source/2022/q_exercises/sched.rst:89
#: ../source/2022/q_exercises/sched.rst:105
msgid "P3"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:20
#: ../source/2022/q_exercises/sched.rst:36
#: ../source/2022/q_exercises/sched.rst:44
#: ../source/2022/q_exercises/sched.rst:60
#: ../source/2022/q_exercises/sched.rst:67
#: ../source/2022/q_exercises/sched.rst:83
#: ../source/2022/q_exercises/sched.rst:89
#: ../source/2022/q_exercises/sched.rst:107
msgid "P4"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:22
#: ../source/2022/q_exercises/sched.rst:46
#: ../source/2022/q_exercises/sched.rst:69
#: ../source/2022/q_exercises/sched.rst:91
msgid "CPU Release Time"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:23
#: ../source/2022/q_exercises/sched.rst:70
#: ../source/2022/q_exercises/sched.rst:107
msgid "1.00"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:23
#: ../source/2022/q_exercises/sched.rst:32
#: ../source/2022/q_exercises/sched.rst:34
msgid "1.5"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:23
#: ../source/2022/q_exercises/sched.rst:34
#: ../source/2022/q_exercises/sched.rst:36
msgid "1.83"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:23
#: ../source/2022/q_exercises/sched.rst:36
#: ../source/2022/q_exercises/sched.rst:47
#: ../source/2022/q_exercises/sched.rst:54
#: ../source/2022/q_exercises/sched.rst:70
#: ../source/2022/q_exercises/sched.rst:79
#: ../source/2022/q_exercises/sched.rst:101
msgid "2.08"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:28
#: ../source/2022/q_exercises/sched.rst:52
#: ../source/2022/q_exercises/sched.rst:75
#: ../source/2022/q_exercises/sched.rst:99
msgid "Processo"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:28
#: ../source/2022/q_exercises/sched.rst:52
#: ../source/2022/q_exercises/sched.rst:75
#: ../source/2022/q_exercises/sched.rst:99
msgid "Primo Accesso"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:28
#: ../source/2022/q_exercises/sched.rst:52
#: ../source/2022/q_exercises/sched.rst:75
#: ../source/2022/q_exercises/sched.rst:99
msgid "Completamento"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:30
#: ../source/2022/q_exercises/sched.rst:60
#: ../source/2022/q_exercises/sched.rst:77
msgid "0"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:30
#: ../source/2022/q_exercises/sched.rst:32
#: ../source/2022/q_exercises/sched.rst:77
#: ../source/2022/q_exercises/sched.rst:83
msgid "1"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:39
msgid "*SPN*:"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:41
msgid ""
"Assunzione 1: Lo scheduler viene attivato dopo l'arrivo di tutti i "
"processi"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:47
#: ../source/2022/q_exercises/sched.rst:58
#: ../source/2022/q_exercises/sched.rst:60
msgid "0.25"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:47
#: ../source/2022/q_exercises/sched.rst:56
#: ../source/2022/q_exercises/sched.rst:58
msgid "0.58"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:47
#: ../source/2022/q_exercises/sched.rst:54
#: ../source/2022/q_exercises/sched.rst:56
msgid "1.08"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:64
msgid "Assunzione 2: Lo scheduler è attivato all'arrivo del primo processo"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:70
#: ../source/2022/q_exercises/sched.rst:81
#: ../source/2022/q_exercises/sched.rst:83
msgid "1.25"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:70
#: ../source/2022/q_exercises/sched.rst:79
#: ../source/2022/q_exercises/sched.rst:81
#: ../source/2022/q_exercises/sched.rst:103
msgid "1.58"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:86
msgid "*RR*:"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
#: ../source/2022/q_exercises/sched.rst:103
msgid "0.125"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
#: ../source/2022/q_exercises/sched.rst:105
msgid "0.250"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
#: ../source/2022/q_exercises/sched.rst:107
msgid "0.375"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "0.500"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "0.625"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "0.750"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "0.875"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "1.000"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "1.125"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "1.250"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "1.333"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "1.458"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "1.583"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:92
msgid "2.083"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:101
msgid "0.000"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:105
msgid "1.33"
msgstr ""

#: ../source/2022/q_exercises/sched.rst:112
msgid ""
"Si consideri uno scenario in cui uno scheduler Multilevel-feedback queue "
"abbia 4 livelli di priorità, ed in cui il quanto di tempo assegnato ai "
"processi al livello i sia di 1/2^i millisecondi. Si supponga che "
"all'istante T0 nascano 2 processi A e B, entrambi CPU-bound. Il processo "
"B richiede 10 millisecondi di tempo di CPU per completare la sua "
"esecuzione. Si identifichi la durata massima (in termini di tempo di CPU)"
" del processo A affinché il processo B possa completare la sua esecuzione"
" entro il tempo T0+17 nei due casi in cui il primo processo ad essere "
"schedulato in CPU sia A oppure B. Si supponga che il tempo di CPU per i "
"context switch e per l'esecuzione dello scheduler sia nullo."
msgstr ""

#: ../source/2022/q_exercises/sched.rst:113
msgid ""
"Si consideri uno scenario in cui al tempo T0 nasca un processo P0 "
"puramente CPU-bound di durata (tempo di CPU) pari a 10 secondi ed al "
"tempo T0 + 3 secondi P0 origini un altro processo P1 puramente CPU-bound "
"di durata (tempo di CPU) pari a 6 secondi. Supponendo che le durate dei "
"processi siano note al tempo della loro generazione, e che il tempo di "
"CPU per eseguire uno scheduler sia trascurabile. si calcoli il tempo "
"massimo di completamento del processo P1 nel caso in cui il sistema abbia"
" come scheduler Shortest Process Next oppure Shortest-Remaining-Time "
"Next."
msgstr ""

#: ../source/2022/questions.rst:44
msgid "Esercizi di programmazione"
msgstr ""

#: ../source/2022/questions.rst:49
msgid ""
"Alcuni esercizi possono deliberatamente ammettere più di una "
"implementazione. Di conseguenza, le soluzioni proposte potrebbe non "
"essere le uniche ammissibili."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:2
msgid "1 - Riscaldamento"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:4
#: ../source/2022/q_exercises/programming.rst:11
msgid "Scrivere un programma che:"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:6
msgid ""
"prende una stringa da tastiera e la inserisce all’interno di un buffer "
"allocato dinamicamente nella heap da parte della funzione scanf()."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:7
msgid ""
"Copia poi tale stringa all’interno di un secondo buffer allocato sullo "
"stack della taglia necessaria a contenerla."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:8
msgid "Libera quindi il buffer allocato nella heap."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:9
msgid "Stampa sullo schermo la stringa copiata nel buffer allocato sullo stack."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:13
msgid ""
"prende una stringa passata come primo argomento (i.e. :code:`char "
"*argv[]`) al programma stesso quando questo viene eseguito."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:14
msgid ""
"Copia tale stringa all’interno di un buffer di dimensione fissa facendo "
"attenzione a non superare il limite imposto dalla taglia, e stamparla "
"quindi sullo schermo."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:15
msgid ""
"Rigira la stringa (primo carattere in ultima posizione, secondo carattere"
" in penultima posizione, ecc.) senza fare utilizzo di un ulteriore buffer"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:16
msgid "Stampa anche questa stringa sullo schermo."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:20
msgid "2 - Processi e threads"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:23
#: ../source/2022/q_exercises/programming.rst:29
#: ../source/2022/q_exercises/programming.rst:35
msgid "Scrivere un programma in C che:"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:25
#: ../source/2022/q_exercises/programming.rst:31
msgid ""
"prende inizialmente una stringa da input (può contenere anche spazi "
"bianchi) e la salva in un buffer"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:26
msgid ""
"fork-a un processo figlio che manda in stampa la stessa stringa acquisita"
" dal processo padre."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:27
msgid ""
"Il processo padre termina solo dopo che il processo figlio ha terminato "
"(verificare che tale ordine è rispettato stampando i PID dei processi)."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:32
msgid ""
"fork-are 2 processi figli che contribuiscono a stampare la stringa "
"inversa della stringa acquisita dal processo padre."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:33
msgid "Il processo padre termina solo dopo che i processi figli hanno terminato."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:37
msgid ""
"prende inizialmente N (a piacere) stringhe rappresentanti N directory "
"corrette"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:38
msgid ""
"fork-a quindi N processi che andranno ad eseguire il comando ls su una "
"directory differente."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:39
msgid "Il processo padre termina dopo i processi figli"
msgstr ""

#: ../source/2022/q_exercises/programming.rst:41
msgid "Svolgere l'esercizio 2.1 utilizzando threads piuttosto che processi."
msgstr ""

#: ../source/2022/q_exercises/programming.rst:42
msgid "Svolgere l'esercizio 2.2 utilizzando threads piuttosto che processi."
msgstr ""

#~ msgid "# Scrivere un programma che:"
#~ msgstr ""

#~ msgid "8- Programmazione"
#~ msgstr ""

#~ msgid "Riscaldamento"
#~ msgstr ""

#~ msgid "Esercizi"
#~ msgstr ""

#~ msgid "Programmazione"
#~ msgstr ""

#~ msgid ""
#~ "*Il processo padre termina solo dopo "
#~ "che il processo figlio ha terminato "
#~ "(verificare che tale ordine è rispettato"
#~ " stampando i PID dei processi)."
#~ msgstr ""

#~ msgid "Svolgere l'esercizio 1 utilizzando threads piuttosto che processi."
#~ msgstr ""

#~ msgid "Svolgere l'esercizio 2 utilizzando threads piuttosto che processi."
#~ msgstr ""

